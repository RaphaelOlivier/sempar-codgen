params = [ ]
else :
params = [ source [ 1 ] ]
return [ source [ 0 ] ] , [ params ]
result = [ ` ` ]
result_args = [ [ ] ]
pos = last = 0
for pos , elt in enumerate ( source ) :
if isinstance ( elt , six . string_types ) :
continue
piece = ` ` . join ( source [ last : pos ] )
if isinstance ( elt , Group ) :
piece + = elt [ 0 ]
param = elt [ 1 ]
else :
param = None
last = pos + 1
for i in range ( len ( result ) ) :
result [ i ] + = piece
if param :
result_args [ i ] . append ( param )
if isinstance ( elt , ( Choice , Non Capture ) ) :
if isinstance ( elt , Non Capture ) :
elt = [ elt ]
inner_result , inner_args = [ ] , [ ]
for item in elt :
res , args = flatten_result ( item )
inner_result . extend ( res )
inner_args . extend ( args )
new_result = [ ]
new_args = [ ]
for item , args in zip ( result , result_args ) :
for i_item , i_args in zip ( inner_result , inner_args ) :
new_result . append ( item + i_item )
new_args . append ( args [ : ] + i_args )
result = new_result
result_args = new_args
if pos > = last :
piece = ` ` . join ( source [ last : ] )
for i in range ( len ( result ) ) :
result [ i ] + = piece
return result , result_args
from django . utils . functional import curry , Promise
from django . utils import six
class Escape Data ( object ) :
pass
class Escape Bytes ( bytes , Escape Data ) :
pass
class Escape Text ( six . text_type , Escape Data ) :
pass
if six . PY3 :
Escape String = Escape Text
else :
Escape String = Escape Bytes
Escape Unicode = Escape Text
class Safe Data ( object ) :
def __html__ ( self ) :
return self
class Safe Bytes ( bytes , Safe Data ) :
def __add__ ( self , rhs ) :
t = super ( Safe Bytes , self ) . __add__ ( rhs )
if isinstance ( rhs , Safe Text ) :
return Safe Text ( t )
elif isinstance ( rhs , Safe Bytes ) :
return Safe Bytes ( t )
return t
def _proxy_method ( self , * args , * * kwargs ) :
method = kwargs . pop ( ` method ` )
data = method ( self , * args , * * kwargs )
if isinstance ( data , bytes ) :
return Safe Bytes ( data )
else :
return Safe Text ( data )
decode = curry ( _proxy_method , method = bytes . decode )
class Safe Text ( six . text_type , Safe Data ) :
def __add__ ( self , rhs ) :
t = super ( Safe Text , self ) . __add__ ( rhs )
if isinstance ( rhs , Safe Data ) :
return Safe Text ( t )
return t
def _proxy_method ( self , * args , * * kwargs ) :
method = kwargs . pop ( ` method ` )
data = method ( self , * args , * * kwargs )
if isinstance ( data , bytes ) :
return Safe Bytes ( data )
else :
return Safe Text ( data )
encode = curry ( _proxy_method , method = six . text_type . encode )
if six . PY3 :
Safe String = Safe Text
else :
Safe String = Safe Bytes
Safe Unicode = Safe Text
def mark_safe ( s ) :
if isinstance ( s , Safe Data ) :
return s
if isinstance ( s , bytes ) or ( isinstance ( s , Promise ) and s . _delegate_bytes ) :
return Safe Bytes ( s )
if isinstance ( s , ( six . text_type , Promise ) ) :
return Safe Text ( s )
return Safe String ( str ( s ) )
def mark_for_escaping ( s ) :
if isinstance ( s , ( Safe Data , Escape Data ) ) :
return s
if isinstance ( s , bytes ) or ( isinstance ( s , Promise ) and s . _delegate_bytes ) :
return Escape Bytes ( s )
if isinstance ( s , ( six . text_type , Promise ) ) :
return Escape Text ( s )
return Escape Bytes ( bytes ( s ) )
import operator
import sys
import types
__author__ = ` Benjamin Peterson < benjamin @ python . org > `
__version__ = ` 1 . 6 . 1 `
PY2 = sys . version_info [ 0 ] = = 2
PY3 = sys . version_info [ 0 ] = = 3
if PY3 :
string_types = str ,
integer_types = int ,
class_types = type ,
text_type = str
binary_type = bytes
MAXSIZE = sys . maxsize
else :
string_types = basestring ,
integer_types = ( int , long )
class_types = ( type , types . Class Type )
text_type = unicode
binary_type = str
if sys . platform . startswith ( ` java ` ) :
MAXSIZE = int ( ( 1 < < 31 ) - 1 )
else :
class X ( object ) :
def __len__ ( self ) :
return 1 < < 31
try :
len ( X ( ) )
except Overflow Error :
MAXSIZE = int ( ( 1 < < 31 ) - 1 )
else :
MAXSIZE = int ( ( 1 < < 63 ) - 1 )
del X
def _add_doc ( func , doc ) :
func . __doc__ = doc
def _import_module ( name ) :
__import__ ( name )
return sys . modules [ name ]
class _Lazy Descr ( object ) :
def __init__ ( self , name ) :
self . name = name
def __get__ ( self , obj , tp ) :
try :
result = self . _resolve ( )
except Import Error :
raise Attribute Error ( ` % s could not be imported ` % self . name )
setattr ( obj , self . name , result )
delattr ( obj . __class__ , self . name )
return result
class Moved Module ( _Lazy Descr ) :
def __init__ ( self , name , old , new = None ) :
super ( Moved Module , self ) . __init__ ( name )
if PY3 :
if new is None :
new = name
self . mod = new
else :
self . mod = old
def _resolve ( self ) :
return _import_module ( self . mod )
def __getattr__ ( self , attr ) :
if ( attr in ( ` __file__ ` , ` __name__ ` , ` __path__ ` ) and self . mod not in sys . modules ) :
raise Attribute Error ( attr )
try :
_module = self . _resolve ( )
except Import Error :
raise Attribute Error ( attr )
value = getattr ( _module , attr )
setattr ( self , attr , value )
return value
class _Lazy Module ( types . Module Type ) :
def __init__ ( self , name ) :
super ( _Lazy Module , self ) . __init__ ( name )
self . __doc__ = self . __class__ . __doc__
def __dir__ ( self ) :
attrs = [ ` __doc__ ` , ` __name__ ` ]
attrs + = [ attr . name for attr in self . _moved_attributes ]
return attrs
_moved_attributes = [ ]
class Moved Attribute ( _Lazy Descr ) :
def __init__ ( self , name , old_mod , new_mod , old_attr = None , new_attr = None ) :
super ( Moved Attribute , self ) . __init__ ( name )
if PY3 :
if new_mod is None :
new_mod = name
self . mod = new_mod
if new_attr is None :
if old_attr is None :
new_attr = name
else :
new_attr = old_attr
self . attr = new_attr
else :
self . mod = old_mod
if old_attr is None :
old_attr = name
self . attr = old_attr
def _resolve ( self ) :
module = _import_module ( self . mod )
return getattr ( module , self . attr )
class _Moved Items ( _Lazy Module ) :
_moved_attributes = [ Moved Attribute ( ` c String IO ` , ` c String IO ` , ` io ` , ` String IO ` ) , Moved Attribute ( ` filter ` , ` itertools ` , ` builtins ` , ` ifilter ` , ` filter ` ) , Moved Attribute ( ` filterfalse ` , ` itertools ` , ` itertools ` , ` ifilterfalse ` , ` filterfalse ` ) , Moved Attribute ( ` input ` , ` __builtin__ ` , ` builtins ` , ` raw_input ` , ` input ` ) , Moved Attribute ( ` map ` , ` itertools ` , ` builtins ` , ` imap ` , ` map ` ) , Moved Attribute ( ` range ` , ` __builtin__ ` , ` builtins ` , ` xrange ` , ` range ` ) , Moved Attribute ( ` reload_module ` , ` __builtin__ ` , ` imp ` , ` reload ` ) , Moved Attribute ( ` reduce ` , ` __builtin__ ` , ` functools ` ) , Moved Attribute ( ` String IO ` , ` String IO ` , ` io ` ) , Moved Attribute ( ` User String ` , ` User String ` , ` collections ` ) , Moved Attribute ( ` xrange ` , ` __builtin__ ` , ` builtins ` , ` xrange ` , ` range ` ) , Moved Attribute ( ` zip ` , ` itertools ` , ` builtins ` , ` izip ` , ` zip ` ) , Moved Attribute ( ` zip_longest ` , ` itertools ` , ` itertools ` , ` izip_longest ` , ` zip_longest ` ) , Moved Module ( ` builtins ` , ` __builtin__ ` ) , Moved Module ( ` configparser ` , ` Config Parser ` ) , Moved Module ( ` copyreg ` , ` copy_reg ` ) , Moved Module ( ` dbm_gnu ` , ` gdbm ` , ` dbm . gnu ` ) , Moved Module ( ` http_cookiejar ` , ` cookielib ` , ` http . cookiejar ` ) , Moved Module ( ` http_cookies ` , ` Cookie ` , ` http . cookies ` ) , Moved Module ( ` html_entities ` , ` htmlentitydefs ` , ` html . entities ` ) , Moved Module ( ` html_parser ` , ` HTMLParser ` , ` html . parser ` ) , Moved Module ( ` http_client ` , ` httplib ` , ` http . client ` ) , Moved Module ( ` email_mime_multipart ` , ` email . MIMEMultipart ` , ` email . mime . multipart ` ) , Moved Module ( ` email_mime_text ` , ` email . MIMEText ` , ` email . mime . text ` ) , Moved Module ( ` email_mime_base ` , ` email . MIMEBase ` , ` email . mime . base ` ) , Moved Module ( ` Base HTTPServer ` , ` Base HTTPServer ` , ` http . server ` ) , Moved Module ( ` CGIHTTPServer ` , ` CGIHTTPServer ` , ` http . server ` ) , Moved Module ( ` Simple HTTPServer ` , ` Simple HTTPServer ` , ` http . server ` ) , Moved Module ( ` c Pickle ` , ` c Pickle ` , ` pickle ` ) , Moved Module ( ` queue ` , ` Queue ` ) , Moved Module ( ` reprlib ` , ` repr ` ) , Moved Module ( ` socketserver ` , ` Socket Server ` ) , Moved Module ( ` _thread ` , ` thread ` , ` _thread ` ) , Moved Module ( ` tkinter ` , ` Tkinter ` ) , Moved Module ( ` tkinter_dialog ` , ` Dialog ` , ` tkinter . dialog ` ) , Moved Module ( ` tkinter_filedialog ` , ` File Dialog ` , ` tkinter . filedialog ` ) , Moved Module ( ` tkinter_scrolledtext ` , ` Scrolled Text ` , ` tkinter . scrolledtext ` ) , Moved Module ( ` tkinter_simpledialog ` , ` Simple Dialog ` , ` tkinter . simpledialog ` ) , Moved Module ( ` tkinter_tix ` , ` Tix ` , ` tkinter . tix ` ) , Moved Module ( ` tkinter_ttk ` , ` ttk ` , ` tkinter . ttk ` ) , Moved Module ( ` tkinter_constants ` , ` Tkconstants ` , ` tkinter . constants ` ) , Moved Module ( ` tkinter_dnd ` , ` Tkdnd ` , ` tkinter . dnd ` ) , Moved Module ( ` tkinter_colorchooser ` , ` tk Color Chooser ` , ` tkinter . colorchooser ` ) , Moved Module ( ` tkinter_commondialog ` , ` tk Common Dialog ` , ` tkinter . commondialog ` ) , Moved Module ( ` tkinter_tkfiledialog ` , ` tk File Dialog ` , ` tkinter . filedialog ` ) , Moved Module ( ` tkinter_font ` , ` tk Font ` , ` tkinter . font ` ) , Moved Module ( ` tkinter_messagebox ` , ` tk Message Box ` , ` tkinter . messagebox ` ) , Moved Module ( ` tkinter_tksimpledialog ` , ` tk Simple Dialog ` , ` tkinter . simpledialog ` ) , Moved Module ( ` urllib_parse ` , __name__ + ` . moves . urllib_parse ` , ` urllib . parse ` ) , Moved Module ( ` urllib_error ` , __name__ + ` . moves . urllib_error ` , ` urllib . error ` ) , Moved Module ( ` urllib ` , __name__ + ` . moves . urllib ` , __name__ + ` . moves . urllib ` ) , Moved Module ( ` urllib_robotparser ` , ` robotparser ` , ` urllib . robotparser ` ) , Moved Module ( ` xmlrpc_client ` , ` xmlrpclib ` , ` xmlrpc . client ` ) , Moved Module ( ` xmlrpc_server ` , ` xmlrpclib ` , ` xmlrpc . server ` ) , Moved Module ( ` winreg ` , ` _winreg ` ) , ]
for attr in _moved_attributes :
setattr ( _Moved Items , attr . name , attr )
if isinstance ( attr , Moved Module ) :
sys . modules [ __name__ + ` . moves . ` + attr . name ] = attr
del attr
_Moved Items . _moved_attributes = _moved_attributes
moves = sys . modules [ __name__ + ` . moves ` ] = _Moved Items ( __name__ + ` . moves ` )
class Module_six_moves_urllib_parse ( _Lazy Module ) :
_urllib_parse_moved_attributes = [ Moved Attribute ( ` Parse Result ` , ` urlparse ` , ` urllib . parse ` ) , Moved Attribute ( ` Split Result ` , ` urlparse ` , ` urllib . parse ` ) , Moved Attribute ( ` parse_qs ` , ` urlparse ` , ` urllib . parse ` ) , Moved Attribute ( ` parse_qsl ` , ` urlparse ` , ` urllib . parse ` ) , Moved Attribute ( ` urldefrag ` , ` urlparse ` , ` urllib . parse ` ) , Moved Attribute ( ` urljoin ` , ` urlparse ` , ` urllib . parse ` ) , Moved Attribute ( ` urlparse ` , ` urlparse ` , ` urllib . parse ` ) , Moved Attribute ( ` urlsplit ` , ` urlparse ` , ` urllib . parse ` ) , Moved Attribute ( ` urlunparse ` , ` urlparse ` , ` urllib . parse ` ) , Moved Attribute ( ` urlunsplit ` , ` urlparse ` , ` urllib . parse ` ) , Moved Attribute ( ` quote ` , ` urllib ` , ` urllib . parse ` ) , Moved Attribute ( ` quote_plus ` , ` urllib ` , ` urllib . parse ` ) , Moved Attribute ( ` unquote ` , ` urllib ` , ` urllib . parse ` ) , Moved Attribute ( ` unquote_plus ` , ` urllib ` , ` urllib . parse ` ) , Moved Attribute ( ` urlencode ` , ` urllib ` , ` urllib . parse ` ) , Moved Attribute ( ` splitquery ` , ` urllib ` , ` urllib . parse ` ) , ]
for attr in _urllib_parse_moved_attributes :
setattr ( Module_six_moves_urllib_parse , attr . name , attr )
del attr
Module_six_moves_urllib_parse . _moved_attributes = _urllib_parse_moved_attributes
sys . modules [ __name__ + ` . moves . urllib_parse ` ] = sys . modules [ __name__ + ` . moves . urllib . parse ` ] = Module_six_moves_urllib_parse ( __name__ + ` . moves . urllib_parse ` )
class Module_six_moves_urllib_error ( _Lazy Module ) :
for attr in _urllib_error_moved_attributes :
setattr ( Module_six_moves_urllib_error , attr . name , attr )
del attr
Module_six_moves_urllib_error . _moved_attributes = _urllib_error_moved_attributes
sys . modules [ __name__ + ` . moves . urllib_error ` ] = sys . modules [ __name__ + ` . moves . urllib . error ` ] = Module_six_moves_urllib_error ( __name__ + ` . moves . urllib . error ` )
class Module_six_moves_urllib_request ( _Lazy Module ) :
_urllib_request_moved_attributes = [ Moved Attribute ( ` urlopen ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` install_opener ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` build_opener ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` pathname2url ` , ` urllib ` , ` urllib . request ` ) , Moved Attribute ( ` url2pathname ` , ` urllib ` , ` urllib . request ` ) , Moved Attribute ( ` getproxies ` , ` urllib ` , ` urllib . request ` ) , Moved Attribute ( ` Request ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` Opener Director ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` HTTPDefault Error Handler ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` HTTPRedirect Handler ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` HTTPCookie Processor ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` Proxy Handler ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` Base Handler ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` HTTPPassword Mgr ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` HTTPPassword Mgr With Default Realm ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` Abstract Basic Auth Handler ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` HTTPBasic Auth Handler ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` Proxy Basic Auth Handler ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` Abstract Digest Auth Handler ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` HTTPDigest Auth Handler ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` Proxy Digest Auth Handler ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` HTTPHandler ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` HTTPSHandler ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` File Handler ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` FTPHandler ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` Cache FTPHandler ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` Unknown Handler ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` HTTPError Processor ` , ` urllib2 ` , ` urllib . request ` ) , Moved Attribute ( ` urlretrieve ` , ` urllib ` , ` urllib . request ` ) , Moved Attribute ( ` urlcleanup ` , ` urllib ` , ` urllib . request ` ) , Moved Attribute ( ` URLopener ` , ` urllib ` , ` urllib . request ` ) , Moved Attribute ( ` Fancy URLopener ` , ` urllib ` , ` urllib . request ` ) , Moved Attribute ( ` proxy_bypass ` , ` urllib ` , ` urllib . request ` ) , ]
for attr in _urllib_request_moved_attributes :
setattr ( Module_six_moves_urllib_request , attr . name , attr )
del attr
Module_six_moves_urllib_request . _moved_attributes = _urllib_request_moved_attributes
sys . modules [ __name__ + ` . moves . urllib_request ` ] = sys . modules [ __name__ + ` . moves . urllib . request ` ] = Module_six_moves_urllib_request ( __name__ + ` . moves . urllib . request ` )
class Module_six_moves_urllib_response ( _Lazy Module ) :
for attr in _urllib_response_moved_attributes :
setattr ( Module_six_moves_urllib_response , attr . name , attr )
del attr
Module_six_moves_urllib_response . _moved_attributes = _urllib_response_moved_attributes
sys . modules [ __name__ + ` . moves . urllib_response ` ] = sys . modules [ __name__ + ` . moves . urllib . response ` ] = Module_six_moves_urllib_response ( __name__ + ` . moves . urllib . response ` )
class Module_six_moves_urllib_robotparser ( _Lazy Module ) :
for attr in _urllib_robotparser_moved_attributes :
setattr ( Module_six_moves_urllib_robotparser , attr . name , attr )
del attr
Module_six_moves_urllib_robotparser . _moved_attributes = _urllib_robotparser_moved_attributes
sys . modules [ __name__ + ` . moves . urllib_robotparser ` ] = sys . modules [ __name__ + ` . moves . urllib . robotparser ` ] = Module_six_moves_urllib_robotparser ( __name__ + ` . moves . urllib . robotparser ` )
class Module_six_moves_urllib ( types . Module Type ) :
parse = sys . modules [ __name__ + ` . moves . urllib_parse ` ]
error = sys . modules [ __name__ + ` . moves . urllib_error ` ]
request = sys . modules [ __name__ + ` . moves . urllib_request ` ]
response = sys . modules [ __name__ + ` . moves . urllib_response ` ]
robotparser = sys . modules [ __name__ + ` . moves . urllib_robotparser ` ]
def __dir__ ( self ) :
return [ ` parse ` , ` error ` , ` request ` , ` response ` , ` robotparser ` ]
sys . modules [ __name__ + ` . moves . urllib ` ] = Module_six_moves_urllib ( __name__ + ` . moves . urllib ` )
def add_move ( move ) :
setattr ( _Moved Items , move . name , move )
def remove_move ( name ) :
try :
delattr ( _Moved Items , name )
except Attribute Error :
try :
del moves . __dict__ [ name ]
except Key Error :
raise Attribute Error ( ` no such move , % r ` % ( name , ) )
if PY3 :
_meth_func = ` __func__ `
_meth_self = ` __self__ `
_func_closure = ` __closure__ `
_func_code = ` __code__ `
_func_defaults = ` __defaults__ `
_func_globals = ` __globals__ `
_iterkeys = ` keys `
_itervalues = ` values `
_iteritems = ` items `
_iterlists = ` lists `
else :
_meth_func = ` im_func `
_meth_self = ` im_self `
_func_closure = ` func_closure `
_func_code = ` func_code `
_func_defaults = ` func_defaults `
_func_globals = ` func_globals `
_iterkeys = ` iterkeys `
_itervalues = ` itervalues `
_iteritems = ` iteritems `
_iterlists = ` iterlists `
try :
advance_iterator = next
except Name Error :
def advance_iterator ( it ) :
return it . next ( )
next = advance_iterator
try :
callable = callable
except Name Error :
def callable ( obj ) :
return any ( ` __call__ ` in klass . __dict__ for klass in type ( obj ) . __mro__ )
if PY3 :
def get_unbound_function ( unbound ) :
return unbound
create_bound_method = types . Method Type
Iterator = object
else :
def get_unbound_function ( unbound ) :
return unbound . im_func
def create_bound_method ( func , obj ) :
return types . Method Type ( func , obj , obj . __class__ )
class Iterator ( object ) :
def next ( self ) :
return type ( self ) . __next__ ( self )
callable = callable
_add_doc ( get_unbound_function , ` ` ` Get the function out of a possibly unbound function ` ` ` )
get_method_function = operator . attrgetter ( _meth_func )
get_method_self = operator . attrgetter ( _meth_self )
get_function_closure = operator . attrgetter ( _func_closure )
get_function_code = operator . attrgetter ( _func_code )
get_function_defaults = operator . attrgetter ( _func_defaults )
get_function_globals = operator . attrgetter ( _func_globals )
def iterkeys ( d , * * kw ) :
return iter ( getattr ( d , _iterkeys ) ( * * kw ) )
def itervalues ( d , * * kw ) :
return iter ( getattr ( d , _itervalues ) ( * * kw ) )
def iteritems ( d , * * kw ) :
return iter ( getattr ( d , _iteritems ) ( * * kw ) )
def iterlists ( d , * * kw ) :
return iter ( getattr ( d , _iterlists ) ( * * kw ) )
if PY3 :
def b ( s ) :
return s . encode ( ` latin - 1 ` )
def u ( s ) :
return s
unichr = chr
if sys . version_info [ 1 ] < = 1 :
def int2byte ( i ) :
return bytes ( ( i , ) )
else :
int2byte = operator . methodcaller ( ` to_bytes ` , 1 , ` big ` )
byte2int = operator . itemgetter ( 0 )
indexbytes = operator . getitem
iterbytes = iter
import io
String IO = io . String IO
Bytes IO = io . Bytes IO
else :
def b ( s ) :
return s
def u ( s ) :
return unicode ( s . replace ( r ` \ \ ` , r ` \ \ \ \ ` ) , ` unicode_escape ` )
unichr = unichr
int2byte = chr
def byte2int ( bs ) :
return ord ( bs [ 0 ] )
def indexbytes ( buf , i ) :
return ord ( buf [ i ] )
def iterbytes ( buf ) :
return ( ord ( byte ) for byte in buf )
import String IO
String IO = Bytes IO = String IO . String IO
_add_doc ( b , ` ` ` Byte literal ` ` ` )
_add_doc ( u , ` ` ` Text literal ` ` ` )
if PY3 :
exec_ = getattr ( moves . builtins , ` exec ` )
def reraise ( tp , value , tb = None ) :
if value . __traceback__ is not tb :
raise value . with_traceback ( tb )
raise value
else :
def exec_ ( _code_ , _globs_ = None , _locs_ = None ) :
if _globs_ is None :
frame = sys . _getframe ( 1 )
_globs_ = frame . f_globals
if _locs_ is None :
_locs_ = frame . f_locals
del frame
elif _locs_ is None :
_locs_ = _globs_
exec ( ` ` ` exec _code_ in _globs_ , _locs_ ` ` ` )
exec_ ( ` ` ` def reraise ( tp , value , tb = None ) : raise tp , value , tb ` ` ` )
print_ = getattr ( moves . builtins , ` print ` , None )
if print_ is None :
def print_ ( * args , * * kwargs ) :
fp = kwargs . pop ( ` file ` , sys . stdout )
if fp is None :
return
def write ( data ) :
if not isinstance ( data , basestring ) :
data = str ( data )
if ( isinstance ( fp , file ) and isinstance ( data , unicode ) and fp . encoding is not None ) :
errors = getattr ( fp , ` errors ` , None )
if errors is None :
errors = ` strict `
data = data . encode ( fp . encoding , errors )
fp . write ( data )
want_unicode = False
sep = kwargs . pop ( ` sep ` , None )
if sep is not None :
if isinstance ( sep , unicode ) :
want_unicode = True
elif not isinstance ( sep , str ) :
raise Type Error ( ` sep must be None or a string ` )
end = kwargs . pop ( ` end ` , None )
if end is not None :
if isinstance ( end , unicode ) :
want_unicode = True
elif not isinstance ( end , str ) :
raise Type Error ( ` end must be None or a string ` )
if kwargs :
raise Type Error ( ` invalid keyword arguments to print ( ) ` )
if not want_unicode :
for arg in args :
if isinstance ( arg , unicode ) :
want_unicode = True
break
if want_unicode :
newline = unicode ( ` \ n ` )
space = unicode ( ` ` )
else :
newline = ` \ n `
space = ` `
if sep is None :
sep = space
if end is None :
end = newline
for i , arg in enumerate ( args ) :
if i :
write ( sep )
write ( arg )
write ( end )
_add_doc ( reraise , ` ` ` Reraise an exception . ` ` ` )
def with_metaclass ( meta , * bases ) :
class metaclass ( meta ) :
__call__ = type . __call__
__init__ = type . __init__
def __new__ ( cls , name , this_bases , d ) :
if this_bases is None :
return type . __new__ ( cls , name , ( ) , d )
return meta ( name , bases , d )
return metaclass ( ` temporary_class ` , None , { } )
def add_metaclass ( metaclass ) :
def wrapper ( cls ) :
orig_vars = cls . __dict__ . copy ( )
orig_vars . pop ( ` __dict__ ` , None )
orig_vars . pop ( ` __weakref__ ` , None )
slots = orig_vars . get ( ` __slots__ ` )
if slots is not None :
if isinstance ( slots , str ) :
slots = [ slots ]
for slots_var in slots :
orig_vars . pop ( slots_var )
return metaclass ( cls . __name__ , cls . __bases__ , orig_vars )
return wrapper
if PY3 :
_assert Count Equal = ` assert Count Equal `
_assert Raises Regex = ` assert Raises Regex `
_assert Regex = ` assert Regex `
memoryview = memoryview
buffer_types = ( bytes , bytearray , memoryview )
else :
_assert Count Equal = ` assert Items Equal `
_assert Raises Regex = ` assert Raises Regexp `
_assert Regex = ` assert Regexp Matches `
if sys . platform . startswith ( ` java ` ) :
memoryview = memoryview
else :
memoryview = buffer
buffer_types = ( bytearray , memoryview )
def assert Count Equal ( self , * args , * * kwargs ) :
return getattr ( self , _assert Count Equal ) ( * args , * * kwargs )
def assert Raises Regex ( self , * args , * * kwargs ) :
return getattr ( self , _assert Raises Regex ) ( * args , * * kwargs )
def assert Regex ( self , * args , * * kwargs ) :
return getattr ( self , _assert Regex ) ( * args , * * kwargs )
add_move ( Moved Module ( ` _dummy_thread ` , ` dummy_thread ` ) )
add_move ( Moved Module ( ` _thread ` , ` thread ` ) )
import contextlib
try :
import threading
except Import Error :
import dummy_threading as threading
class RWLock ( object ) :
def __init__ ( self ) :
self . mutex = threading . RLock ( )
self . can_read = threading . Semaphore ( 0 )
self . can_write = threading . Semaphore ( 0 )
self . active_readers = 0
self . active_writers = 0
self . waiting_readers = 0
self . waiting_writers = 0
def reader_enters ( self ) :
with self . mutex :
if self . active_writers = = 0 and self . waiting_writers = = 0 :
self . active_readers + = 1
self . can_read . release ( )
else :
self . waiting_readers + = 1
self . can_read . acquire ( )
def reader_leaves ( self ) :
with self . mutex :
self . active_readers - = 1
if self . active_readers = = 0 and self . waiting_writers ! = 0 :
self . active_writers + = 1
self . waiting_writers - = 1
self . can_write . release ( )
@ contextlib . contextmanager
def reader ( self ) :
self . reader_enters ( )
try :
yield
finally :
self . reader_leaves ( )
def writer_enters ( self ) :
with self . mutex :
if self . active_writers = = 0 and self . waiting_writers = = 0 and self . active_readers = = 0 :
self . active_writers + = 1
self . can_write . release ( )
else :
self . waiting_writers + = 1
self . can_write . acquire ( )
def writer_leaves ( self ) :
with self . mutex :
self . active_writers - = 1
if self . waiting_writers ! = 0 :
self . active_writers + = 1
self . waiting_writers - = 1
self . can_write . release ( )
elif self . waiting_readers ! = 0 :
t = self . waiting_readers
self . waiting_readers = 0
self . active_readers + = t
while t > 0 :
self . can_read . release ( )
t - = 1
@ contextlib . contextmanager
def writer ( self ) :
self . writer_enters ( )
try :
yield
finally :
self . writer_leaves ( )
from django . utils import six
color_names = ( ` black ` , ` red ` , ` green ` , ` yellow ` , ` blue ` , ` magenta ` , ` cyan ` , ` white ` )
foreground = dict ( ( color_names [ x ] , ` 3 % s ` % x ) for x in range ( 8 ) )
background = dict ( ( color_names [ x ] , ` 4 % s ` % x ) for x in range ( 8 ) )
RESET = ` 0 `
opt_dict = { ` bold ` : ` 1 ` , ` underscore ` : ` 4 ` , ` blink ` : ` 5 ` , ` reverse ` : ` 7 ` , ` conceal ` : ` 8 ` }
def colorize ( text = ` ` , opts = ( ) , * * kwargs ) :
code_list = [ ]
if text = = ` ` and len ( opts ) = = 1 and opts [ 0 ] = = ` reset ` :
return ` \ x1b [ % sm ` % RESET
for k , v in six . iteritems ( kwargs ) :
if k = = ` fg ` :
code_list . append ( foreground [ v ] )
elif k = = ` bg ` :
code_list . append ( background [ v ] )
for o in opts :
if o in opt_dict :
code_list . append ( opt_dict [ o ] )
if ` noreset ` not in opts :
text = ` % s \ x1b [ % sm ` % ( text or ` ` , RESET )
return ` % s % s ` % ( ( ` \ x1b [ % sm ` % ` ; ` . join ( code_list ) ) , text or ` ` )
def make_style ( opts = ( ) , * * kwargs ) :
return lambda text : colorize ( text , opts , * * kwargs )
NOCOLOR_PALETTE = ` nocolor `
DARK_PALETTE = ` dark `
LIGHT_PALETTE = ` light `
PALETTES = { NOCOLOR_PALETTE : { ` ERROR ` : { } , ` WARNING ` : { } , ` NOTICE ` : { } , ` SQL_FIELD ` : { } , ` SQL_COLTYPE ` : { } , ` SQL_KEYWORD ` : { } , ` SQL_TABLE ` : { } , ` HTTP_INFO ` : { } , ` HTTP_SUCCESS ` : { } , ` HTTP_REDIRECT ` : { } , ` HTTP_NOT_MODIFIED ` : { } , ` HTTP_BAD_REQUEST ` : { } , ` HTTP_NOT_FOUND ` : { } , ` HTTP_SERVER_ERROR ` : { } , ` MIGRATE_HEADING ` : { } , ` MIGRATE_LABEL ` : { } , ` MIGRATE_SUCCESS ` : { } , ` MIGRATE_FAILURE ` : { } , } , DARK_PALETTE : { ` ERROR ` : { ` fg ` : ` red ` , ` opts ` : ( ` bold ` , ) } , ` WARNING ` : { ` fg ` : ` yellow ` , ` opts ` : ( ` bold ` , ) } , ` NOTICE ` : { ` fg ` : ` red ` } , ` SQL_FIELD ` : { ` fg ` : ` green ` , ` opts ` : ( ` bold ` , ) } , ` SQL_COLTYPE ` : { ` fg ` : ` green ` } , ` SQL_KEYWORD ` : { ` fg ` : ` yellow ` } , ` SQL_TABLE ` : { ` opts ` : ( ` bold ` , ) } , ` HTTP_INFO ` : { ` opts ` : ( ` bold ` , ) } , ` HTTP_SUCCESS ` : { } , ` HTTP_REDIRECT ` : { ` fg ` : ` green ` } , ` HTTP_NOT_MODIFIED ` : { ` fg ` : ` cyan ` } , ` HTTP_BAD_REQUEST ` : { ` fg ` : ` red ` , ` opts ` : ( ` bold ` , ) } , ` HTTP_NOT_FOUND ` : { ` fg ` : ` yellow ` } , ` HTTP_SERVER_ERROR ` : { ` fg ` : ` magenta ` , ` opts ` : ( ` bold ` , ) } , ` MIGRATE_HEADING ` : { ` fg ` : ` cyan ` , ` opts ` : ( ` bold ` , ) } , ` MIGRATE_LABEL ` : { ` opts ` : ( ` bold ` , ) } , ` MIGRATE_SUCCESS ` : { ` fg ` : ` green ` , ` opts ` : ( ` bold ` , ) } , ` MIGRATE_FAILURE ` : { ` fg ` : ` red ` , ` opts ` : ( ` bold ` , ) } , } , LIGHT_PALETTE : { ` ERROR ` : { ` fg ` : ` red ` , ` opts ` : ( ` bold ` , ) } , ` WARNING ` : { ` fg ` : ` yellow ` , ` opts ` : ( ` bold ` , ) } , ` NOTICE ` : { ` fg ` : ` red ` } , ` SQL_FIELD ` : { ` fg ` : ` green ` , ` opts ` : ( ` bold ` , ) } , ` SQL_COLTYPE ` : { ` fg ` : ` green ` } , ` SQL_KEYWORD ` : { ` fg ` : ` blue ` } , ` SQL_TABLE ` : { ` opts ` : ( ` bold ` , ) } , ` HTTP_INFO ` : { ` opts ` : ( ` bold ` , ) } , ` HTTP_SUCCESS ` : { } , ` HTTP_REDIRECT ` : { ` fg ` : ` green ` , ` opts ` : ( ` bold ` , ) } , ` HTTP_NOT_MODIFIED ` : { ` fg ` : ` green ` } , ` HTTP_BAD_REQUEST ` : { ` fg ` : ` red ` , ` opts ` : ( ` bold ` , ) } , ` HTTP_NOT_FOUND ` : { ` fg ` : ` red ` } , ` HTTP_SERVER_ERROR ` : { ` fg ` : ` magenta ` , ` opts ` : ( ` bold ` , ) } , ` MIGRATE_HEADING ` : { ` fg ` : ` cyan ` , ` opts ` : ( ` bold ` , ) } , ` MIGRATE_LABEL ` : { ` opts ` : ( ` bold ` , ) } , ` MIGRATE_SUCCESS ` : { ` fg ` : ` green ` , ` opts ` : ( ` bold ` , ) } , ` MIGRATE_FAILURE ` : { ` fg ` : ` red ` , ` opts ` : ( ` bold ` , ) } , } }
DEFAULT_PALETTE = DARK_PALETTE
def parse_color_setting ( config_string ) :
if not config_string :
return PALETTES [ DEFAULT_PALETTE ]
parts = config_string . lower ( ) . split ( ` ; ` )
palette = PALETTES [ NOCOLOR_PALETTE ] . copy ( )
for part in parts :
if part in PALETTES :
palette . update ( PALETTES [ part ] )
elif ` = ` in part :
definition = { }
role , instructions = part . split ( ` = ` )
role = role . upper ( )
styles = instructions . split ( ` , ` )
styles . reverse ( )
colors = styles . pop ( ) . split ( ` / ` )
colors . reverse ( )
fg = colors . pop ( )
if fg in color_names :
definition [ ` fg ` ] = fg
if colors and colors [ - 1 ] in color_names :
definition [ ` bg ` ] = colors [ - 1 ]
opts = tuple ( s for s in styles if s in opt_dict . keys ( ) )
if opts :
definition [ ` opts ` ] = opts
if role in PALETTES [ NOCOLOR_PALETTE ] and definition :
palette [ role ] = definition
if palette = = PALETTES [ NOCOLOR_PALETTE ] :
return None
return palette
from __future__ import unicode_literals
import re
import unicodedata
from gzip import Gzip File
from io import Bytes IO
import warnings
from django . utils . deprecation import Removed In Django19Warning
from django . utils . encoding import force_text
from django . utils . functional import allow_lazy , Simple Lazy Object
from django . utils import six
from django . utils . six . moves import html_entities
from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext
from django . utils . safestring import mark_safe
if six . PY2 :
from django . utils . encoding import force_unicode
capfirst = lambda x : x and force_text ( x ) [ 0 ] . upper ( ) + force_text ( x ) [ 1 : ]
capfirst = allow_lazy ( capfirst , six . text_type )
re_words = re . compile ( r ` < . * ? > | ( ( ? : \ w [ - \ w ] * | & . * ? ; ) + ) ` , re . U | re . S )
re_chars = re . compile ( r ` < . * ? > | ( . ) ` , re . U | re . S )
re_tag = re . compile ( r ` < ( / ) ? ( [ ^ ] + ? ) ( ? : ( \ s * / ) | . * ? ) ? > ` , re . S )
re_newlines = re . compile ( r ` \ r \ n | \ r ` )
re_camel_case = re . compile ( r ` ( ( ( ? < = [ a - z ] ) [ A - Z ] ) | ( [ A - Z ] ( ? ! [ A - Z ] | $ ) ) ) ` )
def wrap ( text , width ) :
text = force_text ( text )
def _generator ( ) :
for line in text . splitlines ( True ) :
max_width = min ( ( line . endswith ( ` \ n ` ) and width + 1 or width ) , width )
while len ( line ) > max_width :
space = line [ : max_width + 1 ] . rfind ( ` ` ) + 1
if space = = 0 :
space = line . find ( ` ` ) + 1
if space = = 0 :
yield line
line = ` `
break
yield ` % s \ n ` % line [ : space - 1 ]
line = line [ space : ]
max_width = min ( ( line . endswith ( ` \ n ` ) and width + 1 or width ) , width )
if line :
yield line
return ` ` . join ( _generator ( ) )
wrap = allow_lazy ( wrap , six . text_type )
class Truncator ( Simple Lazy Object ) :
def __init__ ( self , text ) :
super ( Truncator , self ) . __init__ ( lambda : force_text ( text ) )
def add_truncation_text ( self , text , truncate = None ) :
if truncate is None :
truncate = pgettext ( ` String to return when truncating text ` , ` % ( truncated_text ) s . . . ` )
truncate = force_text ( truncate )
if ` % ( truncated_text ) s ` in truncate :
return truncate % { ` truncated_text ` : text }
if text . endswith ( truncate ) :
return text
return ` % s % s ` % ( text , truncate )
def chars ( self , num , truncate = None , html = False ) :
length = int ( num )
text = unicodedata . normalize ( ` NFC ` , self . _wrapped )
truncate_len = length
for char in self . add_truncation_text ( ` ` , truncate ) :
if not unicodedata . combining ( char ) :
truncate_len - = 1
if truncate_len = = 0 :
break
if html :
return self . _truncate_html ( length , truncate , text , truncate_len , False )
return self . _text_chars ( length , truncate , text , truncate_len )
chars = allow_lazy ( chars )
def _text_chars ( self , length , truncate , text , truncate_len ) :
s_len = 0
end_index = None
for i , char in enumerate ( text ) :
if unicodedata . combining ( char ) :
continue
s_len + = 1
if end_index is None and s_len > truncate_len :
end_index = i
if s_len > length :
return self . add_truncation_text ( text [ : end_index or 0 ] , truncate )
return text
def words ( self , num , truncate = None , html = False ) :
length = int ( num )
if html :
return self . _truncate_html ( length , truncate , self . _wrapped , length , True )
return self . _text_words ( length , truncate )
words = allow_lazy ( words )
def _text_words ( self , length , truncate ) :
words = self . _wrapped . split ( )
if len ( words ) > length :
words = words [ : length ]
return self . add_truncation_text ( ` ` . join ( words ) , truncate )
return ` ` . join ( words )
def _truncate_html ( self , length , truncate , text , truncate_len , words ) :
if words and length < = 0 :
return ` `
html4_singlets = ( ` br ` , ` col ` , ` link ` , ` base ` , ` img ` , ` param ` , ` area ` , ` hr ` , ` input ` )
pos = 0
end_text_pos = 0
current_len = 0
open_tags = [ ]
regex = re_words if words else re_chars
while current_len < = length :
m = regex . search ( text , pos )
if not m :
break
pos = m . end ( 0 )
if m . group ( 1 ) :
current_len + = 1
if current_len = = truncate_len :
end_text_pos = pos
continue
tag = re_tag . match ( m . group ( 0 ) )
if not tag or current_len > = truncate_len :
continue
closing_tag , tagname , self_closing = tag . groups ( )
tagname = tagname . lower ( )
if self_closing or tagname in html4_singlets :
pass
elif closing_tag :
try :
i = open_tags . index ( tagname )
except Value Error :
pass
else :
open_tags = open_tags [ i + 1 : ]
else :
open_tags . insert ( 0 , tagname )
if current_len < = length :
return text
out = text [ : end_text_pos ]
truncate_text = self . add_truncation_text ( ` ` , truncate )
if truncate_text :
out + = truncate_text
for tag in open_tags :
out + = ` < / % s > ` % tag
return out
def get_valid_filename ( s ) :
s = force_text ( s ) . strip ( ) . replace ( ` ` , ` _ ` )
return re . sub ( r ` ( ? u ) [ ^ - \ w . ] ` , ` ` , s )
get_valid_filename = allow_lazy ( get_valid_filename , six . text_type )
def get_text_list ( list_ , last_word = ugettext_lazy ( ` or ` ) ) :
if len ( list_ ) = = 0 :
return ` `
if len ( list_ ) = = 1 :
return force_text ( list_ [ 0 ] )
return ` % s % s % s ` % ( _ ( ` , ` ) . join ( force_text ( i ) for i in list_ [ : - 1 ] ) , force_text ( last_word ) , force_text ( list_ [ - 1 ] ) )
get_text_list = allow_lazy ( get_text_list , six . text_type )
def normalize_newlines ( text ) :
text = force_text ( text )
return re_newlines . sub ( ` \ n ` , text )
normalize_newlines = allow_lazy ( normalize_newlines , six . text_type )
def phone2numeric ( phone ) :
char2number = { ` a ` : ` 2 ` , ` b ` : ` 2 ` , ` c ` : ` 2 ` , ` d ` : ` 3 ` , ` e ` : ` 3 ` , ` f ` : ` 3 ` , ` g ` : ` 4 ` , ` h ` : ` 4 ` , ` i ` : ` 4 ` , ` j ` : ` 5 ` , ` k ` : ` 5 ` , ` l ` : ` 5 ` , ` m ` : ` 6 ` , ` n ` : ` 6 ` , ` o ` : ` 6 ` , ` p ` : ` 7 ` , ` q ` : ` 7 ` , ` r ` : ` 7 ` , ` s ` : ` 7 ` , ` t ` : ` 8 ` , ` u ` : ` 8 ` , ` v ` : ` 8 ` , ` w ` : ` 9 ` , ` x ` : ` 9 ` , ` y ` : ` 9 ` , ` z ` : ` 9 ` }
return ` ` . join ( char2number . get ( c , c ) for c in phone . lower ( ) )
phone2numeric = allow_lazy ( phone2numeric )
def compress_string ( s ) :
zbuf = Bytes IO ( )
zfile = Gzip File ( mode = ` wb ` , compresslevel = 6 , fileobj = zbuf )
zfile . write ( s )
zfile . close ( )
return zbuf . getvalue ( )
class Streaming Buffer ( object ) :
def __init__ ( self ) :
self . vals = [ ]
def write ( self , val ) :
self . vals . append ( val )
def read ( self ) :
ret = b ` ` . join ( self . vals )
self . vals = [ ]
return ret
def flush ( self ) :
return
def close ( self ) :
return
def compress_sequence ( sequence ) :
buf = Streaming Buffer ( )
zfile = Gzip File ( mode = ` wb ` , compresslevel = 6 , fileobj = buf )
yield buf . read ( )
for item in sequence :
zfile . write ( item )
zfile . flush ( )
yield buf . read ( )
zfile . close ( )
yield buf . read ( )
ustring_re = re . compile ( ` ( [ \ u0080 - \ uffff ] ) ` )
def javascript_quote ( s , quote_double_quotes = False ) :
msg = ( ` django . utils . text . javascript_quote ( ) is deprecated . ` ` Use django . utils . html . escapejs ( ) instead . ` )
warnings . warn ( msg , Removed In Django19Warning , stacklevel = 2 )
def fix ( match ) :
return ` \ \ u % 04x ` % ord ( match . group ( 1 ) )
if type ( s ) = = bytes :
s = s . decode ( ` utf - 8 ` )
elif type ( s ) ! = six . text_type :
raise Type Error ( s )
s = s . replace ( ` \ \ ` , ` \ \ \ \ ` )
s = s . replace ( ` \ r ` , ` \ \ r ` )
s = s . replace ( ` \ n ` , ` \ \ n ` )
s = s . replace ( ` \ t ` , ` \ \ t ` )
s = s . replace ( ` ` ` , ` \ \ ` ` )
s = s . replace ( ` < / ` , ` < \ \ / ` )
if quote_double_quotes :
s = s . replace ( ` ` ` , ` & quot ; ` )
return ustring_re . sub ( fix , s )
javascript_quote = allow_lazy ( javascript_quote , six . text_type )
smart_split_re = re . compile ( r ` ` ` ( ( ? : [ ^ \ s ` ` ] * ( ? : ( ? : ` ( ? : [ ^ ` \ \ ] | \ \ . ) * ` | ` ( ? : [ ^ ` \ \ ] | \ \ . ) * ` ) [ ^ \ s ` ` ] * ) + ) | \ S + ) ` ` ` , re . VERBOSE )
def smart_split ( text ) :
text = force_text ( text )
for bit in smart_split_re . finditer ( text ) :
yield bit . group ( 0 )
def _replace_entity ( match ) :
text = match . group ( 1 )
if text [ 0 ] = = ` # ` :
text = text [ 1 : ]
try :
if text [ 0 ] in ` x X ` :
c = int ( text [ 1 : ] , 16 )
else :
c = int ( text )
return six . unichr ( c )
except Value Error :
return match . group ( 0 )
else :
try :
return six . unichr ( html_entities . name2codepoint [ text ] )
except ( Value Error , Key Error ) :
return match . group ( 0 )
_entity_re = re . compile ( r ` & ( # ? [ x X ] ? ( ? : [ 0 - 9a - f A - F ] + | \ w { 1 , 8 } ) ) ; ` )
def unescape_entities ( text ) :
return _entity_re . sub ( _replace_entity , text )
unescape_entities = allow_lazy ( unescape_entities , six . text_type )
def unescape_string_literal ( s ) :
if s [ 0 ] not in ` \ ` ` ` or s [ - 1 ] ! = s [ 0 ] :
raise Value Error ( ` Not a string literal : % r ` % s )
quote = s [ 0 ]
return s [ 1 : - 1 ] . replace ( r ` \ % s ` % quote , quote ) . replace ( r ` \ \ ` , ` \ \ ` )
unescape_string_literal = allow_lazy ( unescape_string_literal )
def slugify ( value ) :
value = unicodedata . normalize ( ` NFKD ` , value ) . encode ( ` ascii ` , ` ignore ` ) . decode ( ` ascii ` )
value = re . sub ( ` [ ^ \ w \ s - ] ` , ` ` , value ) . strip ( ) . lower ( )
return mark_safe ( re . sub ( ` [ - \ s ] + ` , ` - ` , value ) )
slugify = allow_lazy ( slugify , six . text_type )
def camel_case_to_spaces ( value ) :
return re_camel_case . sub ( r ` \ 1 ` , value ) . strip ( ) . lower ( )
from __future__ import unicode_literals
import datetime
from django . utils . html import avoid_wrapping
from django . utils . timezone import is_aware , utc
from django . utils . translation import ugettext , ungettext_lazy
def timesince ( d , now = None , reversed = False ) :
chunks = ( ( 60 * 60 * 24 * 365 , ungettext_lazy ( ` % d year ` , ` % d years ` ) ) , ( 60 * 60 * 24 * 30 , ungettext_lazy ( ` % d month ` , ` % d months ` ) ) , ( 60 * 60 * 24 * 7 , ungettext_lazy ( ` % d week ` , ` % d weeks ` ) ) , ( 60 * 60 * 24 , ungettext_lazy ( ` % d day ` , ` % d days ` ) ) , ( 60 * 60 , ungettext_lazy ( ` % d hour ` , ` % d hours ` ) ) , ( 60 , ungettext_lazy ( ` % d minute ` , ` % d minutes ` ) ) )
if not isinstance ( d , datetime . datetime ) :
d = datetime . datetime ( d . year , d . month , d . day )
if now and not isinstance ( now , datetime . datetime ) :
now = datetime . datetime ( now . year , now . month , now . day )
if not now :
now = datetime . datetime . now ( utc if is_aware ( d ) else None )
delta = ( d - now ) if reversed else ( now - d )
since = delta . days * 24 * 60 * 60 + delta . seconds
if since < = 0 :
return avoid_wrapping ( ugettext ( ` 0 minutes ` ) )
for i , ( seconds , name ) in enumerate ( chunks ) :
count = since / / seconds
if count ! = 0 :
break
result = avoid_wrapping ( name % count )
if i + 1 < len ( chunks ) :
seconds2 , name2 = chunks [ i + 1 ]
if count2 ! = 0 :
result + = ugettext ( ` , ` ) + avoid_wrapping ( name2 % count2 )
return result
def timeuntil ( d , now = None ) :
return timesince ( d , now , reversed = True )
from datetime import datetime , timedelta , tzinfo
from threading import local
import sys
import time as _time
try :
import pytz
except Import Error :
pytz = None
from django . conf import settings
from django . utils import six
__all__ = [ ` utc ` , ` get_fixed_timezone ` , ` get_default_timezone ` , ` get_default_timezone_name ` , ` get_current_timezone ` , ` get_current_timezone_name ` , ` activate ` , ` deactivate ` , ` override ` , ` localtime ` , ` now ` , ` is_aware ` , ` is_naive ` , ` make_aware ` , ` make_naive ` , ]
ZERO = timedelta ( 0 )
class UTC ( tzinfo ) :
def __repr__ ( self ) :
return ` < UTC > `
def utcoffset ( self , dt ) :
return ZERO
def tzname ( self , dt ) :
return ` UTC `
def dst ( self , dt ) :
return ZERO
class Fixed Offset ( tzinfo ) :
def __init__ ( self , offset = None , name = None ) :
if offset is not None :
self . __offset = timedelta ( minutes = offset )
if name is not None :
self . __name = name
def utcoffset ( self , dt ) :
return self . __offset
def tzname ( self , dt ) :
return self . __name
def dst ( self , dt ) :
return ZERO
class Reference Local Timezone ( tzinfo ) :
def __init__ ( self ) :
self . STDOFFSET = timedelta ( seconds = - _time . timezone )
if _time . daylight :
self . DSTOFFSET = timedelta ( seconds = - _time . altzone )
else :
self . DSTOFFSET = self . STDOFFSET
self . DSTDIFF = self . DSTOFFSET - self . STDOFFSET
tzinfo . __init__ ( self )
def utcoffset ( self , dt ) :
if self . _isdst ( dt ) :
return self . DSTOFFSET
else :
return self . STDOFFSET
def dst ( self , dt ) :
if self . _isdst ( dt ) :
return self . DSTDIFF
else :
return ZERO
def tzname ( self , dt ) :
return _time . tzname [ self . _isdst ( dt ) ]
def _isdst ( self , dt ) :
tt = ( dt . year , dt . month , dt . day , dt . hour , dt . minute , dt . second , dt . weekday ( ) , 0 , 0 )
stamp = _time . mktime ( tt )
tt = _time . localtime ( stamp )
return tt . tm_isdst > 0
class Local Timezone ( Reference Local Timezone ) :
def tzname ( self , dt ) :
is_dst = False if dt is None else self . _isdst ( dt )
return _time . tzname [ is_dst ]
def _isdst ( self , dt ) :
try :
return super ( Local Timezone , self ) . _isdst ( dt )
except ( Overflow Error , Value Error ) as exc :
exc_type = type ( exc )
exc_value = exc_type ( ` Unsupported value : % r . You should install pytz . ` % dt )
exc_value . __cause__ = exc
six . reraise ( exc_type , exc_value , sys . exc_info ( ) [ 2 ] )
utc = pytz . utc if pytz else UTC ( )
def get_fixed_timezone ( offset ) :
if isinstance ( offset , timedelta ) :
offset = offset . seconds / / 60
sign = ` - ` if offset < 0 else ` + `
hhmm = ` % 02d % 02d ` % divmod ( abs ( offset ) , 60 )
name = sign + hhmm
return Fixed Offset ( offset , name )
_localtime = None
def get_default_timezone ( ) :
global _localtime
if _localtime is None :
if isinstance ( settings . TIME_ZONE , six . string_types ) and pytz is not None :
_localtime = pytz . timezone ( settings . TIME_ZONE )
else :
_localtime = Local Timezone ( )
return _localtime
def get_default_timezone_name ( ) :
return _get_timezone_name ( get_default_timezone ( ) )
_active = local ( )
def get_current_timezone ( ) :
return getattr ( _active , ` value ` , get_default_timezone ( ) )
def get_current_timezone_name ( ) :
return _get_timezone_name ( get_current_timezone ( ) )
def _get_timezone_name ( timezone ) :
try :
return timezone . zone
except Attribute Error :
return timezone . tzname ( None )
def activate ( timezone ) :
if isinstance ( timezone , tzinfo ) :
_active . value = timezone
elif isinstance ( timezone , six . string_types ) and pytz is not None :
_active . value = pytz . timezone ( timezone )
else :
raise Value Error ( ` Invalid timezone : % r ` % timezone )
def deactivate ( ) :
if hasattr ( _active , ` value ` ) :
del _active . value
class override ( object ) :
def __init__ ( self , timezone ) :
self . timezone = timezone
self . old_timezone = getattr ( _active , ` value ` , None )
def __enter__ ( self ) :
if self . timezone is None :
deactivate ( )
else :
activate ( self . timezone )
def __exit__ ( self , exc_type , exc_value , traceback ) :
if self . old_timezone is None :
deactivate ( )
else :
_active . value = self . old_timezone
def template_localtime ( value , use_tz = None ) :
should_convert = ( isinstance ( value , datetime ) and ( settings . USE_TZ if use_tz is None else use_tz ) and not is_naive ( value ) and getattr ( value , ` convert_to_local_time ` , True ) )
return localtime ( value ) if should_convert else value
def localtime ( value , timezone = None ) :
if timezone is None :
timezone = get_current_timezone ( )
value = value . astimezone ( timezone )
if hasattr ( timezone , ` normalize ` ) :
value = timezone . normalize ( value )
return value
def now ( ) :
if settings . USE_TZ :
return datetime . utcnow ( ) . replace ( tzinfo = utc )
else :
return datetime . now ( )
def is_aware ( value ) :
return value . tzinfo is not None and value . tzinfo . utcoffset ( value ) is not None
def is_naive ( value ) :
return value . tzinfo is None or value . tzinfo . utcoffset ( value ) is None
def make_aware ( value , timezone ) :
if hasattr ( timezone , ` localize ` ) :
return timezone . localize ( value , is_dst = None )
else :
if is_aware ( value ) :
raise Value Error ( ` make_aware expects a naive datetime , got % s ` % value )
return value . replace ( tzinfo = timezone )
def make_naive ( value , timezone ) :
value = value . astimezone ( timezone )
if hasattr ( timezone , ` normalize ` ) :
value = timezone . normalize ( value )
return value . replace ( tzinfo = None )
from __future__ import unicode_literals
import re
from django . utils . encoding import force_text
from django . utils . functional import lazy
from django . utils import six
__all__ = [ ` activate ` , ` deactivate ` , ` override ` , ` deactivate_all ` , ` get_language ` , ` get_language_from_request ` , ` get_language_info ` , ` get_language_bidi ` , ` check_for_language ` , ` to_locale ` , ` templatize ` , ` string_concat ` , ` gettext ` , ` gettext_lazy ` , ` gettext_noop ` , ` ugettext ` , ` ugettext_lazy ` , ` ugettext_noop ` , ` ngettext ` , ` ngettext_lazy ` , ` ungettext ` , ` ungettext_lazy ` , ` pgettext ` , ` pgettext_lazy ` , ` npgettext ` , ` npgettext_lazy ` , ` LANGUAGE_SESSION_KEY ` , ]
LANGUAGE_SESSION_KEY = ` _language `
class Translator Comment Warning ( Syntax Warning ) :
pass
class Trans ( object ) :
def __getattr__ ( self , real_name ) :
from django . conf import settings
if settings . USE_I18N :
from django . utils . translation import trans_real as trans
else :
from django . utils . translation import trans_null as trans
setattr ( self , real_name , getattr ( trans , real_name ) )
return getattr ( trans , real_name )
_trans = Trans ( )
del Trans
def gettext_noop ( message ) :
return _trans . gettext_noop ( message )
ugettext_noop = gettext_noop
def gettext ( message ) :
return _trans . gettext ( message )
def ngettext ( singular , plural , number ) :
return _trans . ngettext ( singular , plural , number )
def ugettext ( message ) :
return _trans . ugettext ( message )
def ungettext ( singular , plural , number ) :
return _trans . ungettext ( singular , plural , number )
def pgettext ( context , message ) :
return _trans . pgettext ( context , message )
def npgettext ( context , singular , plural , number ) :
return _trans . npgettext ( context , singular , plural , number )
gettext_lazy = lazy ( gettext , str )
ugettext_lazy = lazy ( ugettext , six . text_type )
pgettext_lazy = lazy ( pgettext , six . text_type )
def lazy_number ( func , resultclass , number = None , * * kwargs ) :
if isinstance ( number , int ) :
kwargs [ ` number ` ] = number
proxy = lazy ( func , resultclass ) ( * * kwargs )
else :
class Number Aware String ( resultclass ) :
def __mod__ ( self , rhs ) :
if isinstance ( rhs , dict ) and number :
try :
number_value = rhs [ number ]
except Key Error :
raise Key Error ( ` Your dictionary lacks key \ ` % s \ ` . ` ` Please provide it , because it is required to ` ` determine whether string is singular or plural . ` % number )
else :
number_value = rhs
kwargs [ ` number ` ] = number_value
translated = func ( * * kwargs )
try :
translated = translated % rhs
except Type Error :
pass
return translated
proxy = lazy ( lambda * * kwargs : Number Aware String ( ) , Number Aware String ) ( * * kwargs )
return proxy
def ngettext_lazy ( singular , plural , number = None ) :
return lazy_number ( ngettext , str , singular = singular , plural = plural , number = number )
def ungettext_lazy ( singular , plural , number = None ) :
return lazy_number ( ungettext , six . text_type , singular = singular , plural = plural , number = number )
def npgettext_lazy ( context , singular , plural , number = None ) :
return lazy_number ( npgettext , six . text_type , context = context , singular = singular , plural = plural , number = number )
def activate ( language ) :
return _trans . activate ( language )
def deactivate ( ) :
return _trans . deactivate ( )
class override ( object ) :
def __init__ ( self , language , deactivate = False ) :
self . language = language
self . deactivate = deactivate
self . old_language = get_language ( )
def __enter__ ( self ) :
if self . language is not None :
activate ( self . language )
else :
deactivate_all ( )
def __exit__ ( self , exc_type , exc_value , traceback ) :
if self . deactivate :
deactivate ( )
else :
activate ( self . old_language )
def get_language ( ) :
return _trans . get_language ( )
def get_language_bidi ( ) :
return _trans . get_language_bidi ( )
def check_for_language ( lang_code ) :
return _trans . check_for_language ( lang_code )
def to_locale ( language ) :
return _trans . to_locale ( language )
def get_language_from_request ( request , check_path = False ) :
return _trans . get_language_from_request ( request , check_path )
def get_language_from_path ( path ) :
return _trans . get_language_from_path ( path )
def templatize ( src , origin = None ) :
return _trans . templatize ( src , origin )
def deactivate_all ( ) :
return _trans . deactivate_all ( )
def _string_concat ( * strings ) :
return ` ` . join ( force_text ( s ) for s in strings )
string_concat = lazy ( _string_concat , six . text_type )
def get_language_info ( lang_code ) :
from django . conf . locale import LANG_INFO
try :
return LANG_INFO [ lang_code ]
except Key Error :
if ` - ` not in lang_code :
raise Key Error ( ` Unknown language code % s . ` % lang_code )
generic_lang_code = lang_code . split ( ` - ` ) [ 0 ]
try :
return LANG_INFO [ generic_lang_code ]
except Key Error :
raise Key Error ( ` Unknown language code % s and % s . ` % ( lang_code , generic_lang_code ) )
trim_whitespace_re = re . compile ( ` \ s * \ n \ s * ` )
def trim_whitespace ( s ) :
return trim_whitespace_re . sub ( ` ` , s . strip ( ) )
from django . conf import settings
from django . utils . encoding import force_text
from django . utils . safestring import mark_safe , Safe Data
def ngettext ( singular , plural , number ) :
if number = = 1 :
return singular
return plural
ngettext_lazy = ngettext
def ungettext ( singular , plural , number ) :
return force_text ( ngettext ( singular , plural , number ) )
def pgettext ( context , message ) :
return ugettext ( message )
def npgettext ( context , singular , plural , number ) :
return ungettext ( singular , plural , number )
activate = lambda x : None
deactivate = deactivate_all = lambda : None
get_language = lambda : settings . LANGUAGE_CODE
get_language_bidi = lambda : settings . LANGUAGE_CODE in settings . LANGUAGES_BIDI
check_for_language = lambda x : True
def gettext ( message ) :
if isinstance ( message , Safe Data ) :
return mark_safe ( message )
return message
def ugettext ( message ) :
return force_text ( gettext ( message ) )
gettext_noop = gettext_lazy = _ = gettext
def to_locale ( language ) :
p = language . find ( ` - ` )
if p > = 0 :
return language [ : p ] . lower ( ) + ` _ ` + language [ p + 1 : ] . upper ( )
else :
return language . lower ( )
def get_language_from_request ( request , check_path = False ) :
return settings . LANGUAGE_CODE
def get_language_from_path ( request ) :
return None
from __future__ import unicode_literals
from collections import Ordered Dict
import os
import re
import sys
import gettext as gettext_module
from threading import local
import warnings
from django . apps import apps
from django . conf import settings
from django . core . exceptions import App Registry Not Ready
from django . dispatch import receiver
from django . test . signals import setting_changed
from django . utils . deprecation import Removed In Django19Warning
from django . utils . encoding import force_text
from django . utils . _os import upath
from django . utils . safestring import mark_safe , Safe Data
from django . utils import six , lru_cache
from django . utils . six import String IO
from django . utils . translation import Translator Comment Warning , trim_whitespace , LANGUAGE_SESSION_KEY
_translations = { }
_active = local ( )
_default = None
_supported = None
CONTEXT_SEPARATOR = ` \ x04 `
accept_language_re = re . compile ( r ` ` ` ( [ A - Za - z ] { 1 , 8 } ( ? : - [ A - Za - z0 - 9 ] { 1 , 8 } ) * | \ * ) # ` en ` , ` en - au ` , ` x - y - z ` , ` es - 419 ` , ` * ` ( ? : \ s * ; \ s * q = ( 0 ( ? : \ . \ d { , 3 } ) ? | 1 ( ? : . 0 { , 3 } ) ? ) ) ? # Optional ` q = 1 . 00 ` , ` q = 0 . 8 ` ( ? : \ s * , \ s * | $ ) # Multiple accepts per header . ` ` ` , re . VERBOSE )
language_code_re = re . compile ( r ` ^ [ a - z ] { 1 , 8 } ( ? : - [ a - z0 - 9 ] { 1 , 8 } ) * $ ` , re . IGNORECASE )
language_code_prefix_re = re . compile ( r ` ^ / ( [ \ w - ] + ) ( / | $ ) ` )
_BROWSERS_DEPRECATED_LOCALES = { ` zh - cn ` : ` zh - hans ` , ` zh - tw ` : ` zh - hant ` , }
_DJANGO_DEPRECATED_LOCALES = _BROWSERS_DEPRECATED_LOCALES
@ receiver ( setting_changed )
def reset_cache ( * * kwargs ) :
if kwargs [ ` setting ` ] in ( ` LANGUAGES ` , ` LANGUAGE_CODE ` ) :
global _supported
_supported = None
check_for_language . cache_clear ( )
get_supported_language_variant . cache_clear ( )
def to_locale ( language , to_lower = False ) :
p = language . find ( ` - ` )
if p > = 0 :
if to_lower :
return language [ : p ] . lower ( ) + ` _ ` + language [ p + 1 : ] . lower ( )
else :
if len ( language [ p + 1 : ] ) > 2 :
return language [ : p ] . lower ( ) + ` _ ` + language [ p + 1 ] . upper ( ) + language [ p + 2 : ] . lower ( )
return language [ : p ] . lower ( ) + ` _ ` + language [ p + 1 : ] . upper ( )
else :
return language . lower ( )
def to_language ( locale ) :
p = locale . find ( ` _ ` )
if p > = 0 :
return locale [ : p ] . lower ( ) + ` - ` + locale [ p + 1 : ] . lower ( )
else :
return locale . lower ( )
class Django Translation ( gettext_module . GNUTranslations ) :
def __init__ ( self , language ) :
gettext_module . GNUTranslations . __init__ ( self )
self . __language = language
self . __to_language = to_language ( language )
self . __locale = to_locale ( language )
self . plural = lambda n : int ( n ! = 1 )
self . _init_translation_catalog ( )
self . _add_installed_apps_translations ( )
self . _add_local_translations ( )
self . _add_fallback ( )
def __repr__ ( self ) :
return ` < Django Translation lang : % s > ` % self . __language
def _new_gnu_trans ( self , localedir , use_null_fallback = True ) :
translation = gettext_module . translation ( domain = ` django ` , localedir = localedir , languages = [ self . __locale ] , codeset = ` utf - 8 ` , fallback = use_null_fallback )
if not hasattr ( translation , ` _catalog ` ) :
translation . _catalog = { }
translation . _info = { }
return translation
def _init_translation_catalog ( self ) :
settingsfile = upath ( sys . modules [ settings . __module__ ] . __file__ )
localedir = os . path . join ( os . path . dirname ( settingsfile ) , ` locale ` )
use_null_fallback = True
if self . __language = = settings . LANGUAGE_CODE :
use_null_fallback = False
translation = self . _new_gnu_trans ( localedir , use_null_fallback )
self . _info = translation . _info . copy ( )
self . _catalog = translation . _catalog . copy ( )
def _add_installed_apps_translations ( self ) :
try :
app_configs = reversed ( list ( apps . get_app_configs ( ) ) )
except App Registry Not Ready :
raise App Registry Not Ready ( ` The translation infrastructure cannot be initialized before the ` ` apps registry is ready . Check that you don ` t make non - lazy ` ` gettext calls at import time . ` )
for app_config in app_configs :
localedir = os . path . join ( app_config . path , ` locale ` )
translation = self . _new_gnu_trans ( localedir )
self . merge ( translation )
def _add_local_translations ( self ) :
for localedir in reversed ( settings . LOCALE_PATHS ) :
translation = self . _new_gnu_trans ( localedir )
self . merge ( translation )
def _add_fallback ( self ) :
if self . __language = = settings . LANGUAGE_CODE or self . __language = = ` en - us ` :
return
default_translation = translation ( settings . LANGUAGE_CODE )
self . add_fallback ( default_translation )
def merge ( self , other ) :
self . _catalog . update ( other . _catalog )
def language ( self ) :
return self . __language
def to_language ( self ) :
return self . __to_language
def translation ( language ) :
global _translations
if language not in _translations :
_translations [ language ] = Django Translation ( language )
return _translations [ language ]
def activate ( language ) :
if language in _DJANGO_DEPRECATED_LOCALES :
msg = ( ` The use of the language code ` % s ` is deprecated . ` ` Please use the ` % s ` translation instead . ` )
warnings . warn ( msg % ( language , _DJANGO_DEPRECATED_LOCALES [ language ] ) , Removed In Django19Warning , stacklevel = 2 )
_active . value = translation ( language )
def deactivate ( ) :
if hasattr ( _active , ` value ` ) :
del _active . value
def deactivate_all ( ) :
_active . value = gettext_module . Null Translations ( )
def get_language ( ) :
t = getattr ( _active , ` value ` , None )
if t is not None :
try :
return t . to_language ( )
except Attribute Error :
pass
return settings . LANGUAGE_CODE
def get_language_bidi ( ) :
base_lang = get_language ( ) . split ( ` - ` ) [ 0 ]
return base_lang in settings . LANGUAGES_BIDI
def catalog ( ) :
global _default
t = getattr ( _active , ` value ` , None )
if t is not None :
return t
if _default is None :
_default = translation ( settings . LANGUAGE_CODE )
return _default
def do_translate ( message , translation_function ) :
global _default
eol_message = message . replace ( str ( ` \ r \ n ` ) , str ( ` \ n ` ) ) . replace ( str ( ` \ r ` ) , str ( ` \ n ` ) )
t = getattr ( _active , ` value ` , None )
if t is not None :
result = getattr ( t , translation_function ) ( eol_message )
else :
if _default is None :
_default = translation ( settings . LANGUAGE_CODE )
result = getattr ( _default , translation_function ) ( eol_message )
if isinstance ( message , Safe Data ) :
return mark_safe ( result )
return result
def gettext ( message ) :
return do_translate ( message , ` gettext ` )
if six . PY3 :
ugettext = gettext
else :
def ugettext ( message ) :
return do_translate ( message , ` ugettext ` )
def pgettext ( context , message ) :
msg_with_ctxt = ` % s % s % s ` % ( context , CONTEXT_SEPARATOR , message )
result = ugettext ( msg_with_ctxt )
if CONTEXT_SEPARATOR in result :
result = force_text ( message )
return result
def gettext_noop ( message ) :
return message
def do_ntranslate ( singular , plural , number , translation_function ) :
global _default
t = getattr ( _active , ` value ` , None )
if t is not None :
return getattr ( t , translation_function ) ( singular , plural , number )
if _default is None :
_default = translation ( settings . LANGUAGE_CODE )
return getattr ( _default , translation_function ) ( singular , plural , number )
def ngettext ( singular , plural , number ) :
return do_ntranslate ( singular , plural , number , ` ngettext ` )
if six . PY3 :
ungettext = ngettext
else :
def ungettext ( singular , plural , number ) :
return do_ntranslate ( singular , plural , number , ` ungettext ` )
def npgettext ( context , singular , plural , number ) :
msgs_with_ctxt = ( ` % s % s % s ` % ( context , CONTEXT_SEPARATOR , singular ) , ` % s % s % s ` % ( context , CONTEXT_SEPARATOR , plural ) , number )
result = ungettext ( * msgs_with_ctxt )
if CONTEXT_SEPARATOR in result :
result = ungettext ( singular , plural , number )
return result
def all_locale_paths ( ) :
globalpath = os . path . join ( os . path . dirname ( upath ( sys . modules [ settings . __module__ ] . __file__ ) ) , ` locale ` )
return [ globalpath ] + list ( settings . LOCALE_PATHS )
@ lru_cache . lru_cache ( maxsize = 1000 )
def check_for_language ( lang_code ) :
if not language_code_re . search ( lang_code ) :
return False
for path in all_locale_paths ( ) :
if gettext_module . find ( ` django ` , path , [ to_locale ( lang_code ) ] ) is not None :
return True
return False
@ lru_cache . lru_cache ( maxsize = 1000 )
def get_supported_language_variant ( lang_code , strict = False ) :
global _supported
if _supported is None :
_supported = Ordered Dict ( settings . LANGUAGES )
if lang_code :
replacement = _BROWSERS_DEPRECATED_LOCALES . get ( lang_code )
if lang_code not in _supported and replacement in _supported :
return replacement
generic_lang_code = lang_code . split ( ` - ` ) [ 0 ]
for code in ( lang_code , generic_lang_code ) :
if code in _supported and check_for_language ( code ) :
return code
if not strict :
for supported_code in _supported :
if supported_code . startswith ( generic_lang_code + ` - ` ) :
return supported_code
raise Lookup Error ( lang_code )
def get_language_from_path ( path , strict = False ) :
regex_match = language_code_prefix_re . match ( path )
if not regex_match :
return None
lang_code = regex_match . group ( 1 )
try :
return get_supported_language_variant ( lang_code , strict = strict )
except Lookup Error :
return None
def get_language_from_request ( request , check_path = False ) :
global _supported
if _supported is None :
_supported = Ordered Dict ( settings . LANGUAGES )
if check_path :
lang_code = get_language_from_path ( request . path_info )
if lang_code is not None :
return lang_code
if hasattr ( request , ` session ` ) :
lang_code = request . session . get ( LANGUAGE_SESSION_KEY )
if lang_code in _supported and lang_code is not None and check_for_language ( lang_code ) :
return lang_code
lang_code = request . COOKIES . get ( settings . LANGUAGE_COOKIE_NAME )
try :
return get_supported_language_variant ( lang_code )
except Lookup Error :
pass
accept = request . META . get ( ` HTTP_ACCEPT_LANGUAGE ` , ` ` )
for accept_lang , unused in parse_accept_lang_header ( accept ) :
if accept_lang = = ` * ` :
break
if not language_code_re . search ( accept_lang ) :
continue
try :
return get_supported_language_variant ( accept_lang )
except Lookup Error :
continue
try :
return get_supported_language_variant ( settings . LANGUAGE_CODE )
except Lookup Error :
return settings . LANGUAGE_CODE
dot_re = re . compile ( r ` \ S ` )
def blankout ( src , char ) :
return dot_re . sub ( char , src )
endblock_re = re . compile ( r ` ` ` ^ \ s * endblocktrans $ ` ` ` )
plural_re = re . compile ( r ` ` ` ^ \ s * plural $ ` ` ` )
one_percent_re = re . compile ( r ` ` ` ( ? < ! % ) % ( ? ! % ) ` ` ` )
def templatize ( src , origin = None ) :
from django . template import ( Lexer , TOKEN_TEXT , TOKEN_VAR , TOKEN_BLOCK , TOKEN_COMMENT , TRANSLATOR_COMMENT_MARK )
src = force_text ( src , settings . FILE_CHARSET )
out = String IO ( ` ` )
message_context = None
intrans = False
inplural = False
trimmed = False
singular = [ ]
plural = [ ]
incomment = False
comment = [ ]
lineno_comment_map = { }
comment_lineno_cache = None
def join_tokens ( tokens , trim = False ) :
message = ` ` . join ( tokens )
if trim :
message = trim_whitespace ( message )
return message
for t in Lexer ( src , origin ) . tokenize ( ) :
if incomment :
if t . token_type = = TOKEN_BLOCK and t . contents = = ` endcomment ` :
content = ` ` . join ( comment )
translators_comment_start = None
for lineno , line in enumerate ( content . splitlines ( True ) ) :
if line . lstrip ( ) . startswith ( TRANSLATOR_COMMENT_MARK ) :
translators_comment_start = lineno
for lineno , line in enumerate ( content . splitlines ( True ) ) :
if translators_comment_start is not None and lineno > = translators_comment_start :
out . write ( ` # % s ` % line )
else :
out . write ( ` # \ n ` )
incomment = False
comment = [ ]
else :
comment . append ( t . contents )
elif intrans :
if t . token_type = = TOKEN_BLOCK :
endbmatch = endblock_re . match ( t . contents )
pluralmatch = plural_re . match ( t . contents )
if endbmatch :
if inplural :
if message_context :
out . write ( ` npgettext ( % r , % r , % r , count ) ` % ( message_context , join_tokens ( singular , trimmed ) , join_tokens ( plural , trimmed ) ) )
else :
out . write ( ` ngettext ( % r , % r , count ) ` % ( join_tokens ( singular , trimmed ) , join_tokens ( plural , trimmed ) ) )
for part in singular :
out . write ( blankout ( part , ` S ` ) )
for part in plural :
out . write ( blankout ( part , ` P ` ) )
else :
if message_context :
out . write ( ` pgettext ( % r , % r ) ` % ( message_context , join_tokens ( singular , trimmed ) ) )
else :
out . write ( ` gettext ( % r ) ` % join_tokens ( singular , trimmed ) )
for part in singular :
out . write ( blankout ( part , ` S ` ) )
message_context = None
intrans = False
inplural = False
singular = [ ]
plural = [ ]
elif pluralmatch :
inplural = True
else :
filemsg = ` `
if origin :
filemsg = ` file % s , ` % origin
raise Syntax Error ( ` Translation blocks must not include other block tags : % s ( % sline % d ) ` % ( t . contents , filemsg , t . lineno ) )
elif t . token_type = = TOKEN_VAR :
if inplural :
plural . append ( ` % % ( % s ) s ` % t . contents )
else :
singular . append ( ` % % ( % s ) s ` % t . contents )
elif t . token_type = = TOKEN_TEXT :
contents = one_percent_re . sub ( ` % % ` , t . contents )
if inplural :
plural . append ( contents )
else :
singular . append ( contents )
else :
if comment_lineno_cache is not None :
cur_lineno = t . lineno + t . contents . count ( ` \ n ` )
if comment_lineno_cache = = cur_lineno :
if t . token_type ! = TOKEN_COMMENT :
for c in lineno_comment_map [ comment_lineno_cache ] :
filemsg = ` `
if origin :
filemsg = ` file % s , ` % origin
warn_msg = ( ` The translator - targeted comment ` % s ` ` ` ( % sline % d ) was ignored , because it wasn ` t the last item ` ` on the line . ` ) % ( c , filemsg , comment_lineno_cache )
warnings . warn ( warn_msg , Translator Comment Warning )
lineno_comment_map [ comment_lineno_cache ] = [ ]
else :
out . write ( ` # % s ` % ` | ` . join ( lineno_comment_map [ comment_lineno_cache ] ) )
comment_lineno_cache = None
if t . token_type = = TOKEN_BLOCK :
imatch = inline_re . match ( t . contents )
bmatch = block_re . match ( t . contents )
cmatches = constant_re . findall ( t . contents )
if imatch :
g = imatch . group ( 1 )
if g [ 0 ] = = ` ` ` :
g = g . strip ( ` ` ` )
elif g [ 0 ] = = ` ` ` :
g = g . strip ( ` ` ` )
g = one_percent_re . sub ( ` % % ` , g )
if imatch . group ( 2 ) :
context_match = context_re . match ( imatch . group ( 2 ) )
message_context = context_match . group ( 1 )
if message_context [ 0 ] = = ` ` ` :
message_context = message_context . strip ( ` ` ` )
elif message_context [ 0 ] = = ` ` ` :
message_context = message_context . strip ( ` ` ` )
out . write ( ` pgettext ( % r , % r ) ` % ( message_context , g ) )
message_context = None
else :
out . write ( ` gettext ( % r ) ` % g )
elif bmatch :
for fmatch in constant_re . findall ( t . contents ) :
out . write ( ` _ ( % s ) ` % fmatch )
if bmatch . group ( 1 ) :
context_match = context_re . match ( bmatch . group ( 1 ) )
message_context = context_match . group ( 1 )
if message_context [ 0 ] = = ` ` ` :
message_context = message_context . strip ( ` ` ` )
elif message_context [ 0 ] = = ` ` ` :
message_context = message_context . strip ( ` ` ` )
intrans = True
inplural = False
trimmed = ` trimmed ` in t . split_contents ( )
singular = [ ]
plural = [ ]
elif cmatches :
for cmatch in cmatches :
out . write ( ` _ ( % s ) ` % cmatch )
elif t . contents = = ` comment ` :
incomment = True
else :
out . write ( blankout ( t . contents , ` B ` ) )
elif t . token_type = = TOKEN_VAR :
parts = t . contents . split ( ` | ` )
cmatch = constant_re . match ( parts [ 0 ] )
if cmatch :
out . write ( ` _ ( % s ) ` % cmatch . group ( 1 ) )
for p in parts [ 1 : ] :
if p . find ( ` : _ ( ` ) > = 0 :
out . write ( ` % s ` % p . split ( ` : ` , 1 ) [ 1 ] )
else :
out . write ( blankout ( p , ` F ` ) )
elif t . token_type = = TOKEN_COMMENT :
if t . contents . lstrip ( ) . startswith ( TRANSLATOR_COMMENT_MARK ) :
lineno_comment_map . setdefault ( t . lineno , [ ] ) . append ( t . contents )
comment_lineno_cache = t . lineno
else :
out . write ( blankout ( t . contents , ` X ` ) )
return out . getvalue ( )
def parse_accept_lang_header ( lang_string ) :
result = [ ]
pieces = accept_language_re . split ( lang_string . lower ( ) )
if pieces [ - 1 ] :
return [ ]
for i in range ( 0 , len ( pieces ) - 1 , 3 ) :
first , lang , priority = pieces [ i : i + 3 ]
if first :
return [ ]
if priority :
try :
priority = float ( priority )
except Value Error :
return [ ]
if not priority :
priority = 1 . 0
result . append ( ( lang , priority ) )
result . sort ( key = lambda k : k [ 1 ] , reverse = True )
return result
import copy
class Node ( object ) :
default = ` DEFAULT `
def __init__ ( self , children = None , connector = None , negated = False ) :
self . children = children [ : ] if children else [ ]
self . connector = connector or self . default
self . negated = negated
@ classmethod
def _new_instance ( cls , children = None , connector = None , negated = False ) :
obj = Node ( children , connector , negated )
obj . __class__ = cls
return obj
def __str__ ( self ) :
if self . negated :
return ` ( NOT ( % s : % s ) ) ` % ( self . connector , ` , ` . join ( [ str ( c ) for c in self . children ] ) )
return ` ( % s : % s ) ` % ( self . connector , ` , ` . join ( [ str ( c ) for c in self . children ] ) )
def __repr__ ( self ) :
return ` < % s : % s > ` % ( self . __class__ . __name__ , self )
def __deepcopy__ ( self , memodict ) :
obj = Node ( connector = self . connector , negated = self . negated )
obj . __class__ = self . __class__
obj . children = copy . deepcopy ( self . children , memodict )
return obj
def __len__ ( self ) :
return len ( self . children )
def __bool__ ( self ) :
return bool ( self . children )
def __nonzero__ ( self ) :
return type ( self ) . __bool__ ( self )
def __contains__ ( self , other ) :
return other in self . children
def _prepare_data ( self , data ) :
return data
def add ( self , data , conn_type , squash = True ) :
if data in self . children :
return data
data = self . _prepare_data ( data )
if not squash :
self . children . append ( data )
return data
if self . connector = = conn_type :
if ( isinstance ( data , Node ) and not data . negated and ( data . connector = = conn_type or len ( data ) = = 1 ) ) :
self . children . extend ( data . children )
return self
else :
self . children . append ( data )
return data
else :
obj = self . _new_instance ( self . children , self . connector , self . negated )
self . connector = conn_type
self . children = [ obj , data ]
return data
def negate ( self ) :
self . negated = not self . negated
from __future__ import unicode_literals
from datetime import timedelta , tzinfo
import time
import warnings
from django . utils . deprecation import Removed In Django19Warning
from django . utils . encoding import force_str , force_text , DEFAULT_LOCALE_ENCODING
warnings . warn ( ` django . utils . tzinfo will be removed in Django 1 . 9 . ` ` Use django . utils . timezone instead . ` , Removed In Django19Warning , stacklevel = 2 )
class Fixed Offset ( tzinfo ) :
def __init__ ( self , offset ) :
warnings . warn ( ` django . utils . tzinfo . Fixed Offset will be removed in Django 1 . 9 . ` ` Use django . utils . timezone . get_fixed_timezone instead . ` , Removed In Django19Warning )
if isinstance ( offset , timedelta ) :
self . __offset = offset
offset = self . __offset . seconds / / 60
else :
self . __offset = timedelta ( minutes = offset )
sign = ` - ` if offset < 0 else ` + `
self . __name = ` % s % 02d % 02d ` % ( sign , abs ( offset ) / 60 . , abs ( offset ) % 60 )
def __repr__ ( self ) :
return self . __name
def __getinitargs__ ( self ) :
return self . __offset ,
def utcoffset ( self , dt ) :
return self . __offset
def tzname ( self , dt ) :
return self . __name
def dst ( self , dt ) :
return timedelta ( 0 )
class Local Timezone ( tzinfo ) :
def __init__ ( self , dt ) :
warnings . warn ( ` django . utils . tzinfo . Local Timezone will be removed in Django 1 . 9 . ` ` Use django . utils . timezone . get_default_timezone instead . ` , Removed In Django19Warning )
tzinfo . __init__ ( self )
self . __dt = dt
self . _tzname = self . tzname ( dt )
def __repr__ ( self ) :
return force_str ( self . _tzname )
def __getinitargs__ ( self ) :
return self . __dt ,
def utcoffset ( self , dt ) :
if self . _isdst ( dt ) :
return timedelta ( seconds = - time . altzone )
else :
return timedelta ( seconds = - time . timezone )
def dst ( self , dt ) :
if self . _isdst ( dt ) :
return timedelta ( seconds = - time . altzone ) - timedelta ( seconds = - time . timezone )
else :
return timedelta ( 0 )
def tzname ( self , dt ) :
is_dst = False if dt is None else self . _isdst ( dt )
try :
return force_text ( time . tzname [ is_dst ] , DEFAULT_LOCALE_ENCODING )
except Unicode Decode Error :
return None
def _isdst ( self , dt ) :
tt = ( dt . year , dt . month , dt . day , dt . hour , dt . minute , dt . second , dt . weekday ( ) , 0 , 0 )
try :
stamp = time . mktime ( tt )
except ( Overflow Error , Value Error ) :
tt = ( 2037 , ) + tt [ 1 : ]
stamp = time . mktime ( tt )
tt = time . localtime ( stamp )
return tt . tm_isdst > 0
from __future__ import absolute_import
import warnings
from django . utils . deprecation import Removed In Django19Warning
warnings . warn ( ` django . utils . unittest will be removed in Django 1 . 9 . ` , Removed In Django19Warning , stacklevel = 2 )
try :
from unittest2 import *
except Import Error :
from unittest import *
from __future__ import unicode_literals
import datetime
import os
import subprocess
def get_version ( version = None ) :
version = get_complete_version ( version )
major = get_major_version ( version )
sub = ` `
if version [ 3 ] = = ` alpha ` and version [ 4 ] = = 0 :
git_changeset = get_git_changeset ( )
if git_changeset :
sub = ` . dev % s ` % git_changeset
elif version [ 3 ] ! = ` final ` :
mapping = { ` alpha ` : ` a ` , ` beta ` : ` b ` , ` rc ` : ` c ` }
sub = mapping [ version [ 3 ] ] + str ( version [ 4 ] )
return str ( major + sub )
def get_major_version ( version = None ) :
version = get_complete_version ( version )
parts = 2 if version [ 2 ] = = 0 else 3
major = ` . ` . join ( str ( x ) for x in version [ : parts ] )
return major
def get_complete_version ( version = None ) :
if version is None :
from django import VERSION as version
else :
assert len ( version ) = = 5
assert version [ 3 ] in ( ` alpha ` , ` beta ` , ` rc ` , ` final ` )
return version
def get_git_changeset ( ) :
if hasattr ( get_git_changeset , ` cache ` ) :
return get_git_changeset . cache
repo_dir = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) )
git_log = subprocess . Popen ( ` git log - - pretty = format : % ct - - quiet - 1 HEAD ` , stdout = subprocess . PIPE , stderr = subprocess . PIPE , shell = True , cwd = repo_dir , universal_newlines = True )
timestamp = git_log . communicate ( ) [ 0 ]
try :
timestamp = datetime . datetime . utcfromtimestamp ( int ( timestamp ) )
except Value Error :
changeset = None
else :
changeset = timestamp . strftime ( ` % Y % m % d % H % M % S ` )
get_git_changeset . cache = changeset
return changeset
from xml . sax . saxutils import XMLGenerator
class Simpler XMLGenerator ( XMLGenerator ) :
def add Quick Element ( self , name , contents = None , attrs = None ) :
if attrs is None :
attrs = { }
self . start Element ( name , attrs )
if contents is not None :
self . characters ( contents )
self . end Element ( name )
