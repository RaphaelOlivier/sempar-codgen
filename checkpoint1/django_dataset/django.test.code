params = [ ]
else :
params = [ source [ 1 ] ]
return [ source [ 0 ] ] , [ params ]
result = [ '  ' ]
result_args = [ [ ] ]
pos = last = 0
for pos , elt in enumerate ( source ) :
if isinstance ( elt , six . string_types ) :
continue
piece = '  ' . join ( source [ last : pos ] )
if isinstance ( elt , Group ) :
piece += elt [ 0 ]
param = elt [ 1 ]
else :
param = None
last = pos + 1
for i in range ( len ( result ) ) :
result [ i ] += piece
if param :
result_args [ i ] . append ( param )
if isinstance ( elt , ( Choice , NonCapture ) ) :
if isinstance ( elt , NonCapture ) :
elt = [ elt ]
inner_result , inner_args = [ ] , [ ]
for item in elt :
res , args = flatten_result ( item )
inner_result . extend ( res )
inner_args . extend ( args )
new_result = [ ]
new_args = [ ]
for item , args in zip ( result , result_args ) :
for i_item , i_args in zip ( inner_result , inner_args ) :
new_result . append ( item + i_item )
new_args . append ( args [ : ] + i_args )
result = new_result
result_args = new_args
if pos >= last :
piece = '  ' . join ( source [ last : ] )
for i in range ( len ( result ) ) :
result [ i ] += piece
return result , result_args
from django . utils . functional import curry , Promise
from django . utils import six
class EscapeData ( object ) :
pass
class EscapeBytes ( bytes , EscapeData ) :
pass
class EscapeText ( six . text_type , EscapeData ) :
pass
if six . PY3 :
EscapeString = EscapeText
else :
EscapeString = EscapeBytes
EscapeUnicode = EscapeText
class SafeData ( object ) :
def __html__ ( self ) :
return self
class SafeBytes ( bytes , SafeData ) :
def __add__ ( self , rhs ) :
t = super ( SafeBytes , self ) . __add__ ( rhs )
if isinstance ( rhs , SafeText ) :
return SafeText ( t )
elif isinstance ( rhs , SafeBytes ) :
return SafeBytes ( t )
return t
def _proxy_method ( self , * args , ** kwargs ) :
method = kwargs . pop ( ' _STR:0_ ' )
data = method ( self , * args , ** kwargs )
if isinstance ( data , bytes ) :
return SafeBytes ( data )
else :
return SafeText ( data )
decode = curry ( _proxy_method , method = bytes . decode )
class SafeText ( six . text_type , SafeData ) :
def __add__ ( self , rhs ) :
t = super ( SafeText , self ) . __add__ ( rhs )
if isinstance ( rhs , SafeData ) :
return SafeText ( t )
return t
def _proxy_method ( self , * args , ** kwargs ) :
method = kwargs . pop ( ' _STR:0_ ' )
data = method ( self , * args , ** kwargs )
if isinstance ( data , bytes ) :
return SafeBytes ( data )
else :
return SafeText ( data )
encode = curry ( _proxy_method , method = six . text_type . encode )
if six . PY3 :
SafeString = SafeText
else :
SafeString = SafeBytes
SafeUnicode = SafeText
def mark_safe ( s ) :
if isinstance ( s , SafeData ) :
return s
if isinstance ( s , bytes ) or ( isinstance ( s , Promise ) and s . _delegate_bytes ) :
return SafeBytes ( s )
if isinstance ( s , ( six . text_type , Promise ) ) :
return SafeText ( s )
return SafeString ( str ( s ) )
def mark_for_escaping ( s ) :
if isinstance ( s , ( SafeData , EscapeData ) ) :
return s
if isinstance ( s , bytes ) or ( isinstance ( s , Promise ) and s . _delegate_bytes ) :
return EscapeBytes ( s )
if isinstance ( s , ( six . text_type , Promise ) ) :
return EscapeText ( s )
return EscapeBytes ( bytes ( s ) )
import operator
import sys
import types
__author__ = ' _STR:0_ '
__version__ = ' _STR:0_ '
PY2 = sys . version_info [ 0 ] == 2
PY3 = sys . version_info [ 0 ] == 3
if PY3 :
string_types = str ,
integer_types = int ,
class_types = type ,
text_type = str
binary_type = bytes
MAXSIZE = sys . maxsize
else :
string_types = basestring ,
integer_types = ( int , long )
class_types = ( type , types . ClassType )
text_type = unicode
binary_type = str
if sys . platform . startswith ( " java " ) :
MAXSIZE = int ( ( 1 << 31 ) - 1 )
else :
class X ( object ) :
def __len__ ( self ) :
return 1 << 31
try :
len ( X ( ) )
except OverflowError :
MAXSIZE = int ( ( 1 << 31 ) - 1 )
else :
MAXSIZE = int ( ( 1 << 63 ) - 1 )
del X
def _add_doc ( func , doc ) :
func . __doc__ = doc
def _import_module ( name ) :
__import__ ( name )
return sys . modules [ name ]
class _LazyDescr ( object ) :
def __init__ ( self , name ) :
self . name = name
def __get__ ( self , obj , tp ) :
try :
result = self . _resolve ( )
except ImportError :
raise AttributeError ( ' _STR:0_ ' % self . name )
setattr ( obj , self . name , result )
delattr ( obj . __class__ , self . name )
return result
class MovedModule ( _LazyDescr ) :
def __init__ ( self , name , old , new = None ) :
super ( MovedModule , self ) . __init__ ( name )
if PY3 :
if new is None :
new = name
self . mod = new
else :
self . mod = old
def _resolve ( self ) :
return _import_module ( self . mod )
def __getattr__ ( self , attr ) :
if ( attr in ( ' _STR:0_ ' , ' _STR:1_ ' , ' _STR:2_ ' ) and self . mod not in sys . modules ) :
raise AttributeError ( attr )
try :
_module = self . _resolve ( )
except ImportError :
raise AttributeError ( attr )
value = getattr ( _module , attr )
setattr ( self , attr , value )
return value
class _LazyModule ( types . ModuleType ) :
def __init__ ( self , name ) :
super ( _LazyModule , self ) . __init__ ( name )
self . __doc__ = self . __class__ . __doc__
def __dir__ ( self ) :
attrs = [ ' _STR:0_ ' , ' _STR:1_ ' ]
attrs += [ attr . name for attr in self . _moved_attributes ]
return attrs
_moved_attributes = [ ]
class MovedAttribute ( _LazyDescr ) :
def __init__ ( self , name , old_mod , new_mod , old_attr = None , new_attr = None ) :
super ( MovedAttribute , self ) . __init__ ( name )
if PY3 :
if new_mod is None :
new_mod = name
self . mod = new_mod
if new_attr is None :
if old_attr is None :
new_attr = name
else :
new_attr = old_attr
self . attr = new_attr
else :
self . mod = old_mod
if old_attr is None :
old_attr = name
self . attr = old_attr
def _resolve ( self ) :
module = _import_module ( self . mod )
return getattr ( module , self . attr )
class _MovedItems ( _LazyModule ) :
_moved_attributes = [ MovedAttribute ( " cStringIO " , " cStringIO " , " io " , " StringIO " ) , MovedAttribute ( " filter " , " itertools " , " builtins " , " ifilter " , " filter " ) , MovedAttribute ( " filterfalse " , " itertools " , " itertools " , " ifilterfalse " , " filterfalse " ) , MovedAttribute ( " input " , " __builtin__ " , " builtins " , " raw_input " , " input " ) , MovedAttribute ( " map " , " itertools " , " builtins " , " imap " , " map " ) , MovedAttribute ( " range " , " __builtin__ " , " builtins " , " xrange " , " range " ) , MovedAttribute ( " reload_module " , " __builtin__ " , " imp " , " reload " ) , MovedAttribute ( " reduce " , " __builtin__ " , " functools " ) , MovedAttribute ( " StringIO " , " StringIO " , " io " ) , MovedAttribute ( " UserString " , " UserString " , " collections " ) , MovedAttribute ( " xrange " , " __builtin__ " , " builtins " , " xrange " , " range " ) , MovedAttribute ( " zip " , " itertools " , " builtins " , " izip " , " zip " ) , MovedAttribute ( " zip_longest " , " itertools " , " itertools " , " izip_longest " , " zip_longest " ) , MovedModule ( " builtins " , " __builtin__ " ) , MovedModule ( " configparser " , " ConfigParser " ) , MovedModule ( " copyreg " , " copy_reg " ) , MovedModule ( " dbm_gnu " , " gdbm " , " dbm.gnu " ) , MovedModule ( " http_cookiejar " , " cookielib " , " http.cookiejar " ) , MovedModule ( " http_cookies " , " Cookie " , " http.cookies " ) , MovedModule ( " html_entities " , " htmlentitydefs " , " html.entities " ) , MovedModule ( " html_parser " , " HTMLParser " , " html.parser " ) , MovedModule ( " http_client " , " httplib " , " http.client " ) , MovedModule ( " email_mime_multipart " , " email.MIMEMultipart " , " email.mime.multipart " ) , MovedModule ( " email_mime_text " , " email.MIMEText " , " email.mime.text " ) , MovedModule ( " email_mime_base " , " email.MIMEBase " , " email.mime.base " ) , MovedModule ( " BaseHTTPServer " , " BaseHTTPServer " , " http.server " ) , MovedModule ( " CGIHTTPServer " , " CGIHTTPServer " , " http.server " ) , MovedModule ( " SimpleHTTPServer " , " SimpleHTTPServer " , " http.server " ) , MovedModule ( " cPickle " , " cPickle " , " pickle " ) , MovedModule ( " queue " , " Queue " ) , MovedModule ( " reprlib " , " repr " ) , MovedModule ( " socketserver " , " SocketServer " ) , MovedModule ( " _thread " , " thread " , " _thread " ) , MovedModule ( " tkinter " , " Tkinter " ) , MovedModule ( " tkinter_dialog " , " Dialog " , " tkinter.dialog " ) , MovedModule ( " tkinter_filedialog " , " FileDialog " , " tkinter.filedialog " ) , MovedModule ( " tkinter_scrolledtext " , " ScrolledText " , " tkinter.scrolledtext " ) , MovedModule ( " tkinter_simpledialog " , " SimpleDialog " , " tkinter.simpledialog " ) , MovedModule ( " tkinter_tix " , " Tix " , " tkinter.tix " ) , MovedModule ( " tkinter_ttk " , " ttk " , " tkinter.ttk " ) , MovedModule ( " tkinter_constants " , " Tkconstants " , " tkinter.constants " ) , MovedModule ( " tkinter_dnd " , " Tkdnd " , " tkinter.dnd " ) , MovedModule ( " tkinter_colorchooser " , " tkColorChooser " , " tkinter.colorchooser " ) , MovedModule ( " tkinter_commondialog " , " tkCommonDialog " , " tkinter.commondialog " ) , MovedModule ( " tkinter_tkfiledialog " , " tkFileDialog " , " tkinter.filedialog " ) , MovedModule ( " tkinter_font " , " tkFont " , " tkinter.font " ) , MovedModule ( " tkinter_messagebox " , " tkMessageBox " , " tkinter.messagebox " ) , MovedModule ( " tkinter_tksimpledialog " , " tkSimpleDialog " , " tkinter.simpledialog " ) , MovedModule ( " urllib_parse " , __name__ + " .moves.urllib_parse " , " urllib.parse " ) , MovedModule ( " urllib_error " , __name__ + " .moves.urllib_error " , " urllib.error " ) , MovedModule ( " urllib " , __name__ + " .moves.urllib " , __name__ + " .moves.urllib " ) , MovedModule ( " urllib_robotparser " , " robotparser " , " urllib.robotparser " ) , MovedModule ( " xmlrpc_client " , " xmlrpclib " , " xmlrpc.client " ) , MovedModule ( " xmlrpc_server " , " xmlrpclib " , " xmlrpc.server " ) , MovedModule ( " winreg " , " _winreg " ) , ]
for attr in _moved_attributes :
setattr ( _MovedItems , attr . name , attr )
if isinstance ( attr , MovedModule ) :
sys . modules [ __name__ + " .moves. " + attr . name ] = attr
del attr
_MovedItems . _moved_attributes = _moved_attributes
moves = sys . modules [ __name__ + " .moves " ] = _MovedItems ( __name__ + " .moves " )
class Module_six_moves_urllib_parse ( _LazyModule ) :
_urllib_parse_moved_attributes = [ MovedAttribute ( " ParseResult " , " urlparse " , " urllib.parse " ) , MovedAttribute ( " SplitResult " , " urlparse " , " urllib.parse " ) , MovedAttribute ( " parse_qs " , " urlparse " , " urllib.parse " ) , MovedAttribute ( " parse_qsl " , " urlparse " , " urllib.parse " ) , MovedAttribute ( " urldefrag " , " urlparse " , " urllib.parse " ) , MovedAttribute ( " urljoin " , " urlparse " , " urllib.parse " ) , MovedAttribute ( " urlparse " , " urlparse " , " urllib.parse " ) , MovedAttribute ( " urlsplit " , " urlparse " , " urllib.parse " ) , MovedAttribute ( " urlunparse " , " urlparse " , " urllib.parse " ) , MovedAttribute ( " urlunsplit " , " urlparse " , " urllib.parse " ) , MovedAttribute ( " quote " , " urllib " , " urllib.parse " ) , MovedAttribute ( " quote_plus " , " urllib " , " urllib.parse " ) , MovedAttribute ( " unquote " , " urllib " , " urllib.parse " ) , MovedAttribute ( " unquote_plus " , " urllib " , " urllib.parse " ) , MovedAttribute ( " urlencode " , " urllib " , " urllib.parse " ) , MovedAttribute ( " splitquery " , " urllib " , " urllib.parse " ) , ]
for attr in _urllib_parse_moved_attributes :
setattr ( Module_six_moves_urllib_parse , attr . name , attr )
del attr
Module_six_moves_urllib_parse . _moved_attributes = _urllib_parse_moved_attributes
sys . modules [ __name__ + ' _STR:0_ ' ] = sys . modules [ __name__ + " .moves.urllib.parse " ] = Module_six_moves_urllib_parse ( __name__ + ' _STR:0_ ' )
class Module_six_moves_urllib_error ( _LazyModule ) :
_urllib_error_moved_attributes = [ MovedAttribute ( " URLError " , " urllib2 " , " urllib.error " ) , MovedAttribute ( " HTTPError " , " urllib2 " , " urllib.error " ) , MovedAttribute ( " ContentTooShortError " , " urllib " , " urllib.error " ) , ]
for attr in _urllib_error_moved_attributes :
setattr ( Module_six_moves_urllib_error , attr . name , attr )
del attr
Module_six_moves_urllib_error . _moved_attributes = _urllib_error_moved_attributes
sys . modules [ __name__ + " .moves.urllib_error " ] = sys . modules [ __name__ + ' _STR:0_ ' ] = Module_six_moves_urllib_error ( __name__ + ' _STR:0_ ' )
class Module_six_moves_urllib_request ( _LazyModule ) :
_urllib_request_moved_attributes = [ MovedAttribute ( " urlopen " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " install_opener " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " build_opener " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " pathname2url " , " urllib " , " urllib.request " ) , MovedAttribute ( " url2pathname " , " urllib " , " urllib.request " ) , MovedAttribute ( " getproxies " , " urllib " , " urllib.request " ) , MovedAttribute ( " Request " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " OpenerDirector " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " HTTPDefaultErrorHandler " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " HTTPRedirectHandler " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " HTTPCookieProcessor " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " ProxyHandler " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " BaseHandler " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " HTTPPasswordMgr " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " HTTPPasswordMgrWithDefaultRealm " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " AbstractBasicAuthHandler " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " HTTPBasicAuthHandler " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " ProxyBasicAuthHandler " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " AbstractDigestAuthHandler " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " HTTPDigestAuthHandler " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " ProxyDigestAuthHandler " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " HTTPHandler " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " HTTPSHandler " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " FileHandler " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " FTPHandler " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " CacheFTPHandler " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " UnknownHandler " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " HTTPErrorProcessor " , " urllib2 " , " urllib.request " ) , MovedAttribute ( " urlretrieve " , " urllib " , " urllib.request " ) , MovedAttribute ( " urlcleanup " , " urllib " , " urllib.request " ) , MovedAttribute ( " URLopener " , " urllib " , " urllib.request " ) , MovedAttribute ( " FancyURLopener " , " urllib " , " urllib.request " ) , MovedAttribute ( " proxy_bypass " , " urllib " , " urllib.request " ) , ]
for attr in _urllib_request_moved_attributes :
setattr ( Module_six_moves_urllib_request , attr . name , attr )
del attr
Module_six_moves_urllib_request . _moved_attributes = _urllib_request_moved_attributes
sys . modules [ __name__ + " .moves.urllib_request " ] = sys . modules [ __name__ + ' _STR:0_ ' ] = Module_six_moves_urllib_request ( __name__ + ' _STR:0_ ' )
class Module_six_moves_urllib_response ( _LazyModule ) :
_urllib_response_moved_attributes = [ MovedAttribute ( " addbase " , " urllib " , " urllib.response " ) , MovedAttribute ( " addclosehook " , " urllib " , " urllib.response " ) , MovedAttribute ( " addinfo " , " urllib " , " urllib.response " ) , MovedAttribute ( " addinfourl " , " urllib " , " urllib.response " ) , ]
for attr in _urllib_response_moved_attributes :
setattr ( Module_six_moves_urllib_response , attr . name , attr )
del attr
Module_six_moves_urllib_response . _moved_attributes = _urllib_response_moved_attributes
sys . modules [ __name__ + " .moves.urllib_response " ] = sys . modules [ __name__ + ' _STR:0_ ' ] = Module_six_moves_urllib_response ( __name__ + ' _STR:0_ ' )
class Module_six_moves_urllib_robotparser ( _LazyModule ) :
_urllib_robotparser_moved_attributes = [ MovedAttribute ( " RobotFileParser " , " robotparser " , " urllib.robotparser " ) , ]
for attr in _urllib_robotparser_moved_attributes :
setattr ( Module_six_moves_urllib_robotparser , attr . name , attr )
del attr
Module_six_moves_urllib_robotparser . _moved_attributes = _urllib_robotparser_moved_attributes
sys . modules [ __name__ + " .moves.urllib_robotparser " ] = sys . modules [ __name__ + ' _STR:0_ ' ] = Module_six_moves_urllib_robotparser ( __name__ + ' _STR:0_ ' )
class Module_six_moves_urllib ( types . ModuleType ) :
parse = sys . modules [ __name__ + ' _STR:0_ ' ]
error = sys . modules [ __name__ + ' _STR:0_ ' ]
request = sys . modules [ __name__ + ' _STR:0_ ' ]
response = sys . modules [ __name__ + ' _STR:0_ ' ]
robotparser = sys . modules [ __name__ + ' _STR:0_ ' ]
def __dir__ ( self ) :
return [ ' _STR:0_ ' , ' _STR:1_ ' , ' _STR:2_ ' , ' _STR:3_ ' , ' _STR:4_ ' ]
sys . modules [ __name__ + ' _STR:0_ ' ] = Module_six_moves_urllib ( __name__ + ' _STR:0_ ' )
def add_move ( move ) :
setattr ( _MovedItems , move . name , move )
def remove_move ( name ) :
try :
delattr ( _MovedItems , name )
except AttributeError :
try :
del moves . __dict__ [ name ]
except KeyError :
raise AttributeError ( ' _STR:0_ ' % ( name , ) )
if PY3 :
_meth_func = ' _STR:0_ '
_meth_self = ' _STR:0_ '
_func_closure = ' _STR:0_ '
_func_code = ' _STR:0_ '
_func_defaults = ' _STR:0_ '
_func_globals = ' _STR:0_ '
_iterkeys = ' _STR:0_ '
_itervalues = ' _STR:0_ '
_iteritems = ' _STR:0_ '
_iterlists = ' _STR:0_ '
else :
_meth_func = ' _STR:0_ '
_meth_self = ' _STR:0_ '
_func_closure = ' _STR:0_ '
_func_code = ' _STR:0_ '
_func_defaults = ' _STR:0_ '
_func_globals = ' _STR:0_ '
_iterkeys = ' _STR:0_ '
_itervalues = " itervalues "
_iteritems = ' _STR:0_ '
_iterlists = ' _STR:0_ '
try :
advance_iterator = next
except NameError :
def advance_iterator ( it ) :
return it . next ( )
next = advance_iterator
try :
callable = callable
except NameError :
def callable ( obj ) :
return any ( ' _STR:0_ ' in klass . __dict__ for klass in type ( obj ) . __mro__ )
if PY3 :
def get_unbound_function ( unbound ) :
return unbound
create_bound_method = types . MethodType
Iterator = object
else :
def get_unbound_function ( unbound ) :
return unbound . im_func
def create_bound_method ( func , obj ) :
return types . MethodType ( func , obj , obj . __class__ )
class Iterator ( object ) :
def next ( self ) :
return type ( self ) . __next__ ( self )
callable = callable
_add_doc ( get_unbound_function , ' _STR:0_ ' ' _STR:1_ ' ' _STR:0_ ' )
get_method_function = operator . attrgetter ( _meth_func )
get_method_self = operator . attrgetter ( _meth_self )
get_function_closure = operator . attrgetter ( _func_closure )
get_function_code = operator . attrgetter ( _func_code )
get_function_defaults = operator . attrgetter ( _func_defaults )
get_function_globals = operator . attrgetter ( _func_globals )
def iterkeys ( d , ** kw ) :
return iter ( getattr ( d , _iterkeys ) ( ** kw ) )
def itervalues ( d , ** kw ) :
return iter ( getattr ( d , _itervalues ) ( ** kw ) )
def iteritems ( d , ** kw ) :
return iter ( getattr ( d , _iteritems ) ( ** kw ) )
def iterlists ( d , ** kw ) :
return iter ( getattr ( d , _iterlists ) ( ** kw ) )
if PY3 :
def b ( s ) :
return s . encode ( ' _STR:0_ ' )
def u ( s ) :
return s
unichr = chr
if sys . version_info [ 1 ] <= 1 :
def int2byte ( i ) :
return bytes ( ( i , ) )
else :
int2byte = operator . methodcaller ( " to_bytes " , 1 , " big " )
byte2int = operator . itemgetter ( 0 )
indexbytes = operator . getitem
iterbytes = iter
import io
StringIO = io . StringIO
BytesIO = io . BytesIO
else :
def b ( s ) :
return s
def u ( s ) :
return unicode ( s . replace ( r '\\ r , r '\\\\ r ) , ' _STR:1_ ' )
unichr = unichr
int2byte = chr
def byte2int ( bs ) :
return ord ( bs [ 0 ] )
def indexbytes ( buf , i ) :
return ord ( buf [ i ] )
def iterbytes ( buf ) :
return ( ord ( byte ) for byte in buf )
import StringIO
StringIO = BytesIO = StringIO . StringIO
_add_doc ( b , ' _STR:0_ ' " Byte literal'_STR:0_' " )
_add_doc ( u , ' _STR:0_ ' ' _STR:1_ ' ' _STR:0_ ' )
if PY3 :
exec_ = getattr ( moves . builtins , " exec " )
def reraise ( tp , value , tb = None ) :
if value . __traceback__ is not tb :
raise value . with_traceback ( tb )
raise value
else :
def exec_ ( _code_ , _globs_ = None , _locs_ = None ) :
if _globs_ is None :
frame = sys . _getframe ( 1 )
_globs_ = frame . f_globals
if _locs_ is None :
_locs_ = frame . f_locals
del frame
elif _locs_ is None :
_locs_ = _globs_
exec ( ' _STR:0_ ' " exec _code_ in _globs_, _locs_'_STR:0_' " )
exec_ ( ' _STR:0_ ' " def reraise(tp, value, tb=None):     raise tp, value, tb '_STR:0_' " )
print_ = getattr ( moves . builtins , " print " , None )
if print_ is None :
def print_ ( * args , ** kwargs ) :
fp = kwargs . pop ( " file " , sys . stdout )
if fp is None :
return
def write ( data ) :
if not isinstance ( data , basestring ) :
data = str ( data )
if ( isinstance ( fp , file ) and isinstance ( data , unicode ) and fp . encoding is not None ) :
errors = getattr ( fp , " errors " , None )
if errors is None :
errors = ' _STR:0_ '
data = data . encode ( fp . encoding , errors )
fp . write ( data )
want_unicode = False
sep = kwargs . pop ( " sep " , None )
if sep is not None :
if isinstance ( sep , unicode ) :
want_unicode = True
elif not isinstance ( sep , str ) :
raise TypeError ( ' _STR:0_ ' )
end = kwargs . pop ( " end " , None )
if end is not None :
if isinstance ( end , unicode ) :
want_unicode = True
elif not isinstance ( end , str ) :
raise TypeError ( ' _STR:0_ ' )
if kwargs :
raise TypeError ( ' _STR:0_ ' )
if not want_unicode :
for arg in args :
if isinstance ( arg , unicode ) :
want_unicode = True
break
if want_unicode :
newline = unicode ( " \n " )
space = unicode ( "   " )
else :
newline = " \n "
space = ' _STR:0_ '
if sep is None :
sep = space
if end is None :
end = newline
for i , arg in enumerate ( args ) :
if i :
write ( sep )
write ( arg )
write ( end )
_add_doc ( reraise , ' _STR:0_ ' ' _STR:1_ ' ' _STR:0_ ' )
def with_metaclass ( meta , * bases ) :
class metaclass ( meta ) :
__call__ = type . __call__
__init__ = type . __init__
def __new__ ( cls , name , this_bases , d ) :
if this_bases is None :
return type . __new__ ( cls , name , ( ) , d )
return meta ( name , bases , d )
return metaclass ( ' _STR:0_ ' , None , { } )
def add_metaclass ( metaclass ) :
def wrapper ( cls ) :
orig_vars = cls . __dict__ . copy ( )
orig_vars . pop ( ' _STR:0_ ' , None )
orig_vars . pop ( ' _STR:0_ ' , None )
slots = orig_vars . get ( ' _STR:0_ ' )
if slots is not None :
if isinstance ( slots , str ) :
slots = [ slots ]
for slots_var in slots :
orig_vars . pop ( slots_var )
return metaclass ( cls . __name__ , cls . __bases__ , orig_vars )
return wrapper
if PY3 :
_assertCountEqual = ' _STR:0_ '
_assertRaisesRegex = ' _STR:0_ '
_assertRegex = ' _STR:0_ '
memoryview = memoryview
buffer_types = ( bytes , bytearray , memoryview )
else :
_assertCountEqual = ' _STR:0_ '
_assertRaisesRegex = ' _STR:0_ '
_assertRegex = ' _STR:0_ '
if sys . platform . startswith ( ' _STR:0_ ' ) :
memoryview = memoryview
else :
memoryview = buffer
buffer_types = ( bytearray , memoryview )
def assertCountEqual ( self , * args , ** kwargs ) :
return getattr ( self , _assertCountEqual ) ( * args , ** kwargs )
def assertRaisesRegex ( self , * args , ** kwargs ) :
return getattr ( self , _assertRaisesRegex ) ( * args , ** kwargs )
def assertRegex ( self , * args , ** kwargs ) :
return getattr ( self , _assertRegex ) ( * args , ** kwargs )
add_move ( MovedModule ( ' _STR:0_ ' , ' _STR:1_ ' ) )
add_move ( MovedModule ( ' _STR:0_ ' , ' _STR:1_ ' ) )
import contextlib
try :
import threading
except ImportError :
import dummy_threading as threading
class RWLock ( object ) :
def __init__ ( self ) :
self . mutex = threading . RLock ( )
self . can_read = threading . Semaphore ( 0 )
self . can_write = threading . Semaphore ( 0 )
self . active_readers = 0
self . active_writers = 0
self . waiting_readers = 0
self . waiting_writers = 0
def reader_enters ( self ) :
with self . mutex :
if self . active_writers == 0 and self . waiting_writers == 0 :
self . active_readers += 1
self . can_read . release ( )
else :
self . waiting_readers += 1
self . can_read . acquire ( )
def reader_leaves ( self ) :
with self . mutex :
self . active_readers -= 1
if self . active_readers == 0 and self . waiting_writers != 0 :
self . active_writers += 1
self . waiting_writers -= 1
self . can_write . release ( )
@ contextlib . contextmanager
def reader ( self ) :
self . reader_enters ( )
try :
yield
finally :
self . reader_leaves ( )
def writer_enters ( self ) :
with self . mutex :
if self . active_writers == 0 and self . waiting_writers == 0 and self . active_readers == 0 :
self . active_writers += 1
self . can_write . release ( )
else :
self . waiting_writers += 1
self . can_write . acquire ( )
def writer_leaves ( self ) :
with self . mutex :
self . active_writers -= 1
if self . waiting_writers != 0 :
self . active_writers += 1
self . waiting_writers -= 1
self . can_write . release ( )
elif self . waiting_readers != 0 :
t = self . waiting_readers
self . waiting_readers = 0
self . active_readers += t
while t > 0 :
self . can_read . release ( )
t -= 1
@ contextlib . contextmanager
def writer ( self ) :
self . writer_enters ( )
try :
yield
finally :
self . writer_leaves ( )
from django . utils import six
color_names = ( ' _STR:0_ ' , ' _STR:1_ ' , ' _STR:2_ ' , ' _STR:3_ ' , ' _STR:4_ ' , ' _STR:5_ ' , ' _STR:6_ ' , ' _STR:7_ ' )
foreground = dict ( ( color_names [ x ] , ' 3%s ' % x ) for x in range ( 8 ) )
background = dict ( ( color_names [ x ] , ' 4%s ' % x ) for x in range ( 8 ) )
RESET = ' _STR:0_ '
opt_dict = { ' _STR:1_ ' : ' _STR:0_ ' , ' _STR:3_ ' : ' _STR:2_ ' , ' _STR:5_ ' : ' _STR:4_ ' , ' _STR:7_ ' : ' _STR:6_ ' , ' conceal ' : ' 8 ' }
def colorize ( text = '  ' , opts = ( ) , ** kwargs ) :
code_list = [ ]
if text == '  ' and len ( opts ) == 1 and opts [ 0 ] == ' _STR:0_ ' :
return ' _STR:0_ ' % RESET
for k , v in six . iteritems ( kwargs ) :
if k == ' _STR:0_ ' :
code_list . append ( foreground [ v ] )
elif k == ' _STR:0_ ' :
code_list . append ( background [ v ] )
for o in opts :
if o in opt_dict :
code_list . append ( opt_dict [ o ] )
if ' _STR:0_ ' not in opts :
text = ' _STR:0_ ' % ( text or '  ' , RESET )
return ' %s%s ' % ( ( ' _STR:1_ ' % ' _STR:0_ ' . join ( code_list ) ) , text or '  ' )
def make_style ( opts = ( ) , ** kwargs ) :
return lambda text : colorize ( text , opts , ** kwargs )
NOCOLOR_PALETTE = ' _STR:0_ '
DARK_PALETTE = ' _STR:0_ '
LIGHT_PALETTE = ' _STR:0_ '
PALETTES = { NOCOLOR_PALETTE : { ' ERROR ' : { } , ' WARNING ' : { } , ' NOTICE ' : { } , ' SQL_FIELD ' : { } , ' SQL_COLTYPE ' : { } , ' SQL_KEYWORD ' : { } , ' SQL_TABLE ' : { } , ' HTTP_INFO ' : { } , ' HTTP_SUCCESS ' : { } , ' HTTP_REDIRECT ' : { } , ' HTTP_NOT_MODIFIED ' : { } , ' HTTP_BAD_REQUEST ' : { } , ' HTTP_NOT_FOUND ' : { } , ' HTTP_SERVER_ERROR ' : { } , ' MIGRATE_HEADING ' : { } , ' MIGRATE_LABEL ' : { } , ' MIGRATE_SUCCESS ' : { } , ' MIGRATE_FAILURE ' : { } , } , DARK_PALETTE : { ' ERROR ' : { ' fg ' : ' red ' , ' opts ' : ( ' bold ' , ) } , ' WARNING ' : { ' fg ' : ' yellow ' , ' opts ' : ( ' bold ' , ) } , ' NOTICE ' : { ' fg ' : ' red ' } , ' SQL_FIELD ' : { ' fg ' : ' green ' , ' opts ' : ( ' bold ' , ) } , ' SQL_COLTYPE ' : { ' fg ' : ' green ' } , ' SQL_KEYWORD ' : { ' fg ' : ' yellow ' } , ' SQL_TABLE ' : { ' opts ' : ( ' bold ' , ) } , ' HTTP_INFO ' : { ' opts ' : ( ' bold ' , ) } , ' HTTP_SUCCESS ' : { } , ' HTTP_REDIRECT ' : { ' fg ' : ' green ' } , ' HTTP_NOT_MODIFIED ' : { ' fg ' : ' cyan ' } , ' HTTP_BAD_REQUEST ' : { ' fg ' : ' red ' , ' opts ' : ( ' bold ' , ) } , ' HTTP_NOT_FOUND ' : { ' fg ' : ' yellow ' } , ' HTTP_SERVER_ERROR ' : { ' fg ' : ' magenta ' , ' opts ' : ( ' bold ' , ) } , ' MIGRATE_HEADING ' : { ' fg ' : ' cyan ' , ' opts ' : ( ' bold ' , ) } , ' MIGRATE_LABEL ' : { ' opts ' : ( ' bold ' , ) } , ' MIGRATE_SUCCESS ' : { ' fg ' : ' green ' , ' opts ' : ( ' bold ' , ) } , ' MIGRATE_FAILURE ' : { ' fg ' : ' red ' , ' opts ' : ( ' bold ' , ) } , } , LIGHT_PALETTE : { ' ERROR ' : { ' fg ' : ' red ' , ' opts ' : ( ' bold ' , ) } , ' WARNING ' : { ' fg ' : ' yellow ' , ' opts ' : ( ' bold ' , ) } , ' NOTICE ' : { ' fg ' : ' red ' } , ' SQL_FIELD ' : { ' fg ' : ' green ' , ' opts ' : ( ' bold ' , ) } , ' SQL_COLTYPE ' : { ' fg ' : ' green ' } , ' SQL_KEYWORD ' : { ' fg ' : ' blue ' } , ' SQL_TABLE ' : { ' opts ' : ( ' bold ' , ) } , ' HTTP_INFO ' : { ' opts ' : ( ' bold ' , ) } , ' HTTP_SUCCESS ' : { } , ' HTTP_REDIRECT ' : { ' fg ' : ' green ' , ' opts ' : ( ' bold ' , ) } , ' HTTP_NOT_MODIFIED ' : { ' fg ' : ' green ' } , ' HTTP_BAD_REQUEST ' : { ' fg ' : ' red ' , ' opts ' : ( ' bold ' , ) } , ' HTTP_NOT_FOUND ' : { ' fg ' : ' red ' } , ' HTTP_SERVER_ERROR ' : { ' fg ' : ' magenta ' , ' opts ' : ( ' bold ' , ) } , ' MIGRATE_HEADING ' : { ' fg ' : ' cyan ' , ' opts ' : ( ' bold ' , ) } , ' MIGRATE_LABEL ' : { ' opts ' : ( ' bold ' , ) } , ' MIGRATE_SUCCESS ' : { ' fg ' : ' green ' , ' opts ' : ( ' bold ' , ) } , ' MIGRATE_FAILURE ' : { ' fg ' : ' red ' , ' opts ' : ( ' bold ' , ) } , } }
DEFAULT_PALETTE = DARK_PALETTE
def parse_color_setting ( config_string ) :
if not config_string :
return PALETTES [ DEFAULT_PALETTE ]
parts = config_string . lower ( ) . split ( ' _STR:0_ ' )
palette = PALETTES [ NOCOLOR_PALETTE ] . copy ( )
for part in parts :
if part in PALETTES :
palette . update ( PALETTES [ part ] )
elif ' _STR:0_ ' in part :
definition = { }
role , instructions = part . split ( ' _STR:0_ ' )
role = role . upper ( )
styles = instructions . split ( ' _STR:0_ ' )
styles . reverse ( )
colors = styles . pop ( ) . split ( ' _STR:0_ ' )
colors . reverse ( )
fg = colors . pop ( )
if fg in color_names :
definition [ ' _STR:0_ ' ] = fg
if colors and colors [ - 1 ] in color_names :
definition [ ' _STR:0_ ' ] = colors [ - 1 ]
opts = tuple ( s for s in styles if s in opt_dict . keys ( ) )
if opts :
definition [ ' _STR:0_ ' ] = opts
if role in PALETTES [ NOCOLOR_PALETTE ] and definition :
palette [ role ] = definition
if palette == PALETTES [ NOCOLOR_PALETTE ] :
return None
return palette
from __future__ import unicode_literals
import re
import unicodedata
from gzip import GzipFile
from io import BytesIO
import warnings
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils . encoding import force_text
from django . utils . functional import allow_lazy , SimpleLazyObject
from django . utils import six
from django . utils . six . moves import html_entities
from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext
from django . utils . safestring import mark_safe
if six . PY2 :
from django . utils . encoding import force_unicode
capfirst = lambda x : x and force_text ( x ) [ 0 ] . upper ( ) + force_text ( x ) [ 1 : ]
capfirst = allow_lazy ( capfirst , six . text_type )
re_words = re . compile ( r '_STR:0_ r , re . U | re . S )
re_chars = re . compile ( r '_STR:0_ r , re . U | re . S )
re_tag = re . compile ( r '_STR:0_ r , re . S )
re_newlines = re . compile ( r '_STR:0_ r )
re_camel_case = re . compile ( r '_STR:0_ r )
def wrap ( text , width ) :
text = force_text ( text )
def _generator ( ) :
for line in text . splitlines ( True ) :
max_width = min ( ( line . endswith ( ' \n ' ) and width + 1 or width ) , width )
while len ( line ) > max_width :
space = line [ : max_width + 1 ] . rfind ( '   ' ) + 1
if space == 0 :
space = line . find ( '   ' ) + 1
if space == 0 :
yield line
line = '  '
break
yield ' %s\n ' % line [ : space - 1 ]
line = line [ space : ]
max_width = min ( ( line . endswith ( ' \n ' ) and width + 1 or width ) , width )
if line :
yield line
return '  ' . join ( _generator ( ) )
wrap = allow_lazy ( wrap , six . text_type )
class Truncator ( SimpleLazyObject ) :
def __init__ ( self , text ) :
super ( Truncator , self ) . __init__ ( lambda : force_text ( text ) )
def add_truncation_text ( self , text , truncate = None ) :
if truncate is None :
truncate = pgettext ( ' _STR:0_ ' , ' _STR:1_ ' )
truncate = force_text ( truncate )
if ' _STR:0_ ' in truncate :
return truncate % { ' _STR:0_ ' : text }
if text . endswith ( truncate ) :
return text
return ' %s%s ' % ( text , truncate )
def chars ( self , num , truncate = None , html = False ) :
length = int ( num )
text = unicodedata . normalize ( ' _STR:0_ ' , self . _wrapped )
truncate_len = length
for char in self . add_truncation_text ( '  ' , truncate ) :
if not unicodedata . combining ( char ) :
truncate_len -= 1
if truncate_len == 0 :
break
if html :
return self . _truncate_html ( length , truncate , text , truncate_len , False )
return self . _text_chars ( length , truncate , text , truncate_len )
chars = allow_lazy ( chars )
def _text_chars ( self , length , truncate , text , truncate_len ) :
s_len = 0
end_index = None
for i , char in enumerate ( text ) :
if unicodedata . combining ( char ) :
continue
s_len += 1
if end_index is None and s_len > truncate_len :
end_index = i
if s_len > length :
return self . add_truncation_text ( text [ : end_index or 0 ] , truncate )
return text
def words ( self , num , truncate = None , html = False ) :
length = int ( num )
if html :
return self . _truncate_html ( length , truncate , self . _wrapped , length , True )
return self . _text_words ( length , truncate )
words = allow_lazy ( words )
def _text_words ( self , length , truncate ) :
words = self . _wrapped . split ( )
if len ( words ) > length :
words = words [ : length ]
return self . add_truncation_text ( '   ' . join ( words ) , truncate )
return '   ' . join ( words )
def _truncate_html ( self , length , truncate , text , truncate_len , words ) :
if words and length <= 0 :
return '  '
html4_singlets = ( ' _STR:0_ ' , ' _STR:1_ ' , ' _STR:2_ ' , ' _STR:3_ ' , ' _STR:4_ ' , ' _STR:5_ ' , ' _STR:6_ ' , ' _STR:7_ ' , ' _STR:8_ ' )
pos = 0
end_text_pos = 0
current_len = 0
open_tags = [ ]
regex = re_words if words else re_chars
while current_len <= length :
m = regex . search ( text , pos )
if not m :
break
pos = m . end ( 0 )
if m . group ( 1 ) :
current_len += 1
if current_len == truncate_len :
end_text_pos = pos
continue
tag = re_tag . match ( m . group ( 0 ) )
if not tag or current_len >= truncate_len :
continue
closing_tag , tagname , self_closing = tag . groups ( )
tagname = tagname . lower ( )
if self_closing or tagname in html4_singlets :
pass
elif closing_tag :
try :
i = open_tags . index ( tagname )
except ValueError :
pass
else :
open_tags = open_tags [ i + 1 : ]
else :
open_tags . insert ( 0 , tagname )
if current_len <= length :
return text
out = text [ : end_text_pos ]
truncate_text = self . add_truncation_text ( '  ' , truncate )
if truncate_text :
out += truncate_text
for tag in open_tags :
out += ' _STR:0_ ' % tag
return out
def get_valid_filename ( s ) :
s = force_text ( s ) . strip ( ) . replace ( '   ' , ' _ ' )
return re . sub ( r '_STR:1_ r , '  ' , s )
get_valid_filename = allow_lazy ( get_valid_filename , six . text_type )
def get_text_list ( list_ , last_word = ugettext_lazy ( ' _STR:0_ ' ) ) :
if len ( list_ ) == 0 :
return '  '
if len ( list_ ) == 1 :
return force_text ( list_ [ 0 ] )
return ' _STR:0_ ' % ( _ ( ' ,  ' ) . join ( force_text ( i ) for i in list_ [ : - 1 ] ) , force_text ( last_word ) , force_text ( list_ [ - 1 ] ) )
get_text_list = allow_lazy ( get_text_list , six . text_type )
def normalize_newlines ( text ) :
text = force_text ( text )
return re_newlines . sub ( ' _STR:0_ ' , text )
normalize_newlines = allow_lazy ( normalize_newlines , six . text_type )
def phone2numeric ( phone ) :
char2number = { ' _STR:0_ ' : ' 2 ' , ' _STR:1_ ' : ' 2 ' , ' _STR:2_ ' : ' 2 ' , ' _STR:3_ ' : ' 3 ' , ' _STR:4_ ' : ' 3 ' , ' _STR:5_ ' : ' 3 ' , ' _STR:6_ ' : ' 4 ' , ' h ' : ' 4 ' , ' i ' : ' 4 ' , ' j ' : ' 5 ' , ' k ' : ' 5 ' , ' l ' : ' 5 ' , ' m ' : ' 6 ' , ' n ' : ' 6 ' , ' o ' : ' 6 ' , ' p ' : ' 7 ' , ' q ' : ' 7 ' , ' r ' : ' 7 ' , ' s ' : ' 7 ' , ' t ' : ' 8 ' , ' u ' : ' 8 ' , ' v ' : ' 8 ' , ' w ' : ' 9 ' , ' x ' : ' 9 ' , ' y ' : ' 9 ' , ' z ' : ' 9 ' }
return '  ' . join ( char2number . get ( c , c ) for c in phone . lower ( ) )
phone2numeric = allow_lazy ( phone2numeric )
def compress_string ( s ) :
zbuf = BytesIO ( )
zfile = GzipFile ( mode = ' _STR:0_ ' , compresslevel = 6 , fileobj = zbuf )
zfile . write ( s )
zfile . close ( )
return zbuf . getvalue ( )
class StreamingBuffer ( object ) :
def __init__ ( self ) :
self . vals = [ ]
def write ( self , val ) :
self . vals . append ( val )
def read ( self ) :
ret = b ' b . join ( self . vals )
self . vals = [ ]
return ret
def flush ( self ) :
return
def close ( self ) :
return
def compress_sequence ( sequence ) :
buf = StreamingBuffer ( )
zfile = GzipFile ( mode = ' _STR:0_ ' , compresslevel = 6 , fileobj = buf )
yield buf . read ( )
for item in sequence :
zfile . write ( item )
zfile . flush ( )
yield buf . read ( )
zfile . close ( )
yield buf . read ( )
ustring_re = re . compile ( ' _STR:0_ ' )
def javascript_quote ( s , quote_double_quotes = False ) :
msg = ( " django.utils.text.javascript_quote() is deprecated.  " " Use django.utils.html.escapejs() instead. " )
warnings . warn ( msg , RemovedInDjango19Warning , stacklevel = 2 )
def fix ( match ) :
return ' _STR:0_ ' % ord ( match . group ( 1 ) )
if type ( s ) == bytes :
s = s . decode ( ' _STR:0_ ' )
elif type ( s ) != six . text_type :
raise TypeError ( s )
s = s . replace ( ' \\ ' , ' \\\\ ' )
s = s . replace ( ' _STR:0_ ' , ' _STR:1_ ' )
s = s . replace ( ' _STR:0_ ' , ' _STR:1_ ' )
s = s . replace ( ' _STR:0_ ' , ' _STR:1_ ' )
s = s . replace ( ' _STR:0_ ' , ' _STR:1_ ' )
s = s . replace ( ' _STR:0_ ' , ' _STR:1_ ' )
if quote_double_quotes :
s = s . replace ( ' _STR:0_ ' , ' _STR:1_ ' )
return ustring_re . sub ( fix , s )
javascript_quote = allow_lazy ( javascript_quote , six . text_type )
smart_split_re = re . compile ( r """     ((?:         [^\s'"]*         (?:             (?:'_STR:1_'\\]|\\.)*" | '(?:[^'\\]|\\.)*')             [^\s'"]*         )+     ) | \S+) "" r , re . VERBOSE )
def smart_split ( text ) :
text = force_text ( text )
for bit in smart_split_re . finditer ( text ) :
yield bit . group ( 0 )
def _replace_entity ( match ) :
text = match . group ( 1 )
if text [ 0 ] == ' _STR:0_ ' :
text = text [ 1 : ]
try :
if text [ 0 ] in ' _STR:0_ ' :
c = int ( text [ 1 : ] , 16 )
else :
c = int ( text )
return six . unichr ( c )
except ValueError :
return match . group ( 0 )
else :
try :
return six . unichr ( html_entities . name2codepoint [ text ] )
except ( ValueError , KeyError ) :
return match . group ( 0 )
_entity_re = re . compile ( r '_STR:0_ r )
def unescape_entities ( text ) :
return _entity_re . sub ( _replace_entity , text )
unescape_entities = allow_lazy ( unescape_entities , six . text_type )
def unescape_string_literal ( s ) :
if s [ 0 ] not in ' _STR:0_ ' or s [ - 1 ] != s [ 0 ] :
raise ValueError ( ' _STR:0_ ' % s )
quote = s [ 0 ]
return s [ 1 : - 1 ] . replace ( r '_STR:0_ r % quote , quote ) . replace ( r '\\ r , ' \\ ' )
unescape_string_literal = allow_lazy ( unescape_string_literal )
def slugify ( value ) :
value = unicodedata . normalize ( ' _STR:0_ ' , value ) . encode ( ' _STR:1_ ' , ' ignore ' ) . decode ( ' _STR:1_ ' )
value = re . sub ( ' _STR:2_ ' , '  ' , value ) . strip ( ) . lower ( )
return mark_safe ( re . sub ( ' _STR:0_ ' , ' _STR:1_ ' , value ) )
slugify = allow_lazy ( slugify , six . text_type )
def camel_case_to_spaces ( value ) :
return re_camel_case . sub ( r '_STR:0_ r , value ) . strip ( ) . lower ( )
from __future__ import unicode_literals
import datetime
from django . utils . html import avoid_wrapping
from django . utils . timezone import is_aware , utc
from django . utils . translation import ugettext , ungettext_lazy
def timesince ( d , now = None , reversed = False ) :
chunks = ( ( 60 * 60 * 24 * 365 , ungettext_lazy ( ' %d year ' , ' %d years ' ) ) , ( 60 * 60 * 24 * 30 , ungettext_lazy ( ' %d month ' , ' %d months ' ) ) , ( 60 * 60 * 24 * 7 , ungettext_lazy ( ' %d week ' , ' %d weeks ' ) ) , ( 60 * 60 * 24 , ungettext_lazy ( ' %d day ' , ' %d days ' ) ) , ( 60 * 60 , ungettext_lazy ( ' %d hour ' , ' %d hours ' ) ) , ( 60 , ungettext_lazy ( ' %d minute ' , ' %d minutes ' ) ) )
if not isinstance ( d , datetime . datetime ) :
d = datetime . datetime ( d . year , d . month , d . day )
if now and not isinstance ( now , datetime . datetime ) :
now = datetime . datetime ( now . year , now . month , now . day )
if not now :
now = datetime . datetime . now ( utc if is_aware ( d ) else None )
delta = ( d - now ) if reversed else ( now - d )
since = delta . days * 24 * 60 * 60 + delta . seconds
if since <= 0 :
return avoid_wrapping ( ugettext ( ' _STR:0_ ' ) )
for i , ( seconds , name ) in enumerate ( chunks ) :
count = since // seconds
if count != 0 :
break
result = avoid_wrapping ( name % count )
if i + 1 < len ( chunks ) :
seconds2 , name2 = chunks [ i + 1 ]
count2 = ( since - ( seconds * count ) ) // seconds2
if count2 != 0 :
result += ugettext ( ' _STR:0_ ' ) + avoid_wrapping ( name2 % count2 )
return result
def timeuntil ( d , now = None ) :
return timesince ( d , now , reversed = True )
from datetime import datetime , timedelta , tzinfo
from threading import local
import sys
import time as _time
try :
import pytz
except ImportError :
pytz = None
from django . conf import settings
from django . utils import six
__all__ = [ ' _STR:0_ ' , ' _STR:1_ ' , ' _STR:2_ ' , ' _STR:3_ ' , ' get_current_timezone ' , ' get_current_timezone_name ' , ' activate ' , ' deactivate ' , ' override ' , ' localtime ' , ' now ' , ' is_aware ' , ' is_naive ' , ' make_aware ' , ' make_naive ' , ]
ZERO = timedelta ( 0 )
class UTC ( tzinfo ) :
def __repr__ ( self ) :
return ' _STR:0_ '
def utcoffset ( self , dt ) :
return ZERO
def tzname ( self , dt ) :
return ' _STR:0_ '
def dst ( self , dt ) :
return ZERO
class FixedOffset ( tzinfo ) :
def __init__ ( self , offset = None , name = None ) :
if offset is not None :
self . __offset = timedelta ( minutes = offset )
if name is not None :
self . __name = name
def utcoffset ( self , dt ) :
return self . __offset
def tzname ( self , dt ) :
return self . __name
def dst ( self , dt ) :
return ZERO
class ReferenceLocalTimezone ( tzinfo ) :
def __init__ ( self ) :
self . STDOFFSET = timedelta ( seconds = - _time . timezone )
if _time . daylight :
self . DSTOFFSET = timedelta ( seconds = - _time . altzone )
else :
self . DSTOFFSET = self . STDOFFSET
self . DSTDIFF = self . DSTOFFSET - self . STDOFFSET
tzinfo . __init__ ( self )
def utcoffset ( self , dt ) :
if self . _isdst ( dt ) :
return self . DSTOFFSET
else :
return self . STDOFFSET
def dst ( self , dt ) :
if self . _isdst ( dt ) :
return self . DSTDIFF
else :
return ZERO
def tzname ( self , dt ) :
return _time . tzname [ self . _isdst ( dt ) ]
def _isdst ( self , dt ) :
tt = ( dt . year , dt . month , dt . day , dt . hour , dt . minute , dt . second , dt . weekday ( ) , 0 , 0 )
stamp = _time . mktime ( tt )
tt = _time . localtime ( stamp )
return tt . tm_isdst > 0
class LocalTimezone ( ReferenceLocalTimezone ) :
def tzname ( self , dt ) :
is_dst = False if dt is None else self . _isdst ( dt )
return _time . tzname [ is_dst ]
def _isdst ( self , dt ) :
try :
return super ( LocalTimezone , self ) . _isdst ( dt )
except ( OverflowError , ValueError ) as exc :
exc_type = type ( exc )
exc_value = exc_type ( ' _STR:0_ ' % dt )
exc_value . __cause__ = exc
six . reraise ( exc_type , exc_value , sys . exc_info ( ) [ 2 ] )
utc = pytz . utc if pytz else UTC ( )
def get_fixed_timezone ( offset ) :
if isinstance ( offset , timedelta ) :
offset = offset . seconds // 60
sign = ' _STR:0_ ' if offset < 0 else ' _STR:1_ '
hhmm = ' _STR:0_ ' % divmod ( abs ( offset ) , 60 )
name = sign + hhmm
return FixedOffset ( offset , name )
_localtime = None
def get_default_timezone ( ) :
global _localtime
if _localtime is None :
if isinstance ( settings . TIME_ZONE , six . string_types ) and pytz is not None :
_localtime = pytz . timezone ( settings . TIME_ZONE )
else :
_localtime = LocalTimezone ( )
return _localtime
def get_default_timezone_name ( ) :
return _get_timezone_name ( get_default_timezone ( ) )
_active = local ( )
def get_current_timezone ( ) :
return getattr ( _active , " value " , get_default_timezone ( ) )
def get_current_timezone_name ( ) :
return _get_timezone_name ( get_current_timezone ( ) )
def _get_timezone_name ( timezone ) :
try :
return timezone . zone
except AttributeError :
return timezone . tzname ( None )
def activate ( timezone ) :
if isinstance ( timezone , tzinfo ) :
_active . value = timezone
elif isinstance ( timezone , six . string_types ) and pytz is not None :
_active . value = pytz . timezone ( timezone )
else :
raise ValueError ( ' _STR:0_ ' % timezone )
def deactivate ( ) :
if hasattr ( _active , " value " ) :
del _active . value
class override ( object ) :
def __init__ ( self , timezone ) :
self . timezone = timezone
self . old_timezone = getattr ( _active , ' _STR:0_ ' , None )
def __enter__ ( self ) :
if self . timezone is None :
deactivate ( )
else :
activate ( self . timezone )
def __exit__ ( self , exc_type , exc_value , traceback ) :
if self . old_timezone is None :
deactivate ( )
else :
_active . value = self . old_timezone
def template_localtime ( value , use_tz = None ) :
should_convert = ( isinstance ( value , datetime ) and ( settings . USE_TZ if use_tz is None else use_tz ) and not is_naive ( value ) and getattr ( value , ' convert_to_local_time ' , True ) )
return localtime ( value ) if should_convert else value
def localtime ( value , timezone = None ) :
if timezone is None :
timezone = get_current_timezone ( )
value = value . astimezone ( timezone )
if hasattr ( timezone , ' _STR:0_ ' ) :
value = timezone . normalize ( value )
return value
def now ( ) :
if settings . USE_TZ :
return datetime . utcnow ( ) . replace ( tzinfo = utc )
else :
return datetime . now ( )
def is_aware ( value ) :
return value . tzinfo is not None and value . tzinfo . utcoffset ( value ) is not None
def is_naive ( value ) :
return value . tzinfo is None or value . tzinfo . utcoffset ( value ) is None
def make_aware ( value , timezone ) :
if hasattr ( timezone , ' _STR:0_ ' ) :
return timezone . localize ( value , is_dst = None )
else :
if is_aware ( value ) :
raise ValueError ( ' _STR:0_ ' % value )
return value . replace ( tzinfo = timezone )
def make_naive ( value , timezone ) :
value = value . astimezone ( timezone )
if hasattr ( timezone , ' _STR:0_ ' ) :
value = timezone . normalize ( value )
return value . replace ( tzinfo = None )
from __future__ import unicode_literals
import re
from django . utils . encoding import force_text
from django . utils . functional import lazy
from django . utils import six
__all__ = [ ' _STR:0_ ' , ' _STR:1_ ' , ' _STR:2_ ' , ' _STR:3_ ' , ' _STR:4_ ' , ' get_language_from_request ' , ' get_language_info ' , ' get_language_bidi ' , ' check_for_language ' , ' to_locale ' , ' templatize ' , ' string_concat ' , ' gettext ' , ' gettext_lazy ' , ' gettext_noop ' , ' ugettext ' , ' ugettext_lazy ' , ' ugettext_noop ' , ' ngettext ' , ' ngettext_lazy ' , ' ungettext ' , ' ungettext_lazy ' , ' pgettext ' , ' pgettext_lazy ' , ' npgettext ' , ' npgettext_lazy ' , ' LANGUAGE_SESSION_KEY ' , ]
LANGUAGE_SESSION_KEY = ' _STR:22_ '
class TranslatorCommentWarning ( SyntaxWarning ) :
pass
class Trans ( object ) :
def __getattr__ ( self , real_name ) :
from django . conf import settings
if settings . USE_I18N :
from django . utils . translation import trans_real as trans
else :
from django . utils . translation import trans_null as trans
setattr ( self , real_name , getattr ( trans , real_name ) )
return getattr ( trans , real_name )
_trans = Trans ( )
del Trans
def gettext_noop ( message ) :
return _trans . gettext_noop ( message )
ugettext_noop = gettext_noop
def gettext ( message ) :
return _trans . gettext ( message )
def ngettext ( singular , plural , number ) :
return _trans . ngettext ( singular , plural , number )
def ugettext ( message ) :
return _trans . ugettext ( message )
def ungettext ( singular , plural , number ) :
return _trans . ungettext ( singular , plural , number )
def pgettext ( context , message ) :
return _trans . pgettext ( context , message )
def npgettext ( context , singular , plural , number ) :
return _trans . npgettext ( context , singular , plural , number )
gettext_lazy = lazy ( gettext , str )
ugettext_lazy = lazy ( ugettext , six . text_type )
pgettext_lazy = lazy ( pgettext , six . text_type )
def lazy_number ( func , resultclass , number = None , ** kwargs ) :
if isinstance ( number , int ) :
kwargs [ ' _STR:0_ ' ] = number
proxy = lazy ( func , resultclass ) ( ** kwargs )
else :
class NumberAwareString ( resultclass ) :
def __mod__ ( self , rhs ) :
if isinstance ( rhs , dict ) and number :
try :
number_value = rhs [ number ]
except KeyError :
raise KeyError ( ' Your dictionary lacks key \'%s\'.  ' ' Please provide it, because it is required to  ' ' determine whether string is singular or plural. ' % number )
else :
number_value = rhs
kwargs [ ' _STR:0_ ' ] = number_value
translated = func ( ** kwargs )
try :
translated = translated % rhs
except TypeError :
pass
return translated
proxy = lazy ( lambda ** kwargs : NumberAwareString ( ) , NumberAwareString ) ( ** kwargs )
return proxy
def ngettext_lazy ( singular , plural , number = None ) :
return lazy_number ( ngettext , str , singular = singular , plural = plural , number = number )
def ungettext_lazy ( singular , plural , number = None ) :
return lazy_number ( ungettext , six . text_type , singular = singular , plural = plural , number = number )
def npgettext_lazy ( context , singular , plural , number = None ) :
return lazy_number ( npgettext , six . text_type , context = context , singular = singular , plural = plural , number = number )
def activate ( language ) :
return _trans . activate ( language )
def deactivate ( ) :
return _trans . deactivate ( )
class override ( object ) :
def __init__ ( self , language , deactivate = False ) :
self . language = language
self . deactivate = deactivate
self . old_language = get_language ( )
def __enter__ ( self ) :
if self . language is not None :
activate ( self . language )
else :
deactivate_all ( )
def __exit__ ( self , exc_type , exc_value , traceback ) :
if self . deactivate :
deactivate ( )
else :
activate ( self . old_language )
def get_language ( ) :
return _trans . get_language ( )
def get_language_bidi ( ) :
return _trans . get_language_bidi ( )
def check_for_language ( lang_code ) :
return _trans . check_for_language ( lang_code )
def to_locale ( language ) :
return _trans . to_locale ( language )
def get_language_from_request ( request , check_path = False ) :
return _trans . get_language_from_request ( request , check_path )
def get_language_from_path ( path ) :
return _trans . get_language_from_path ( path )
def templatize ( src , origin = None ) :
return _trans . templatize ( src , origin )
def deactivate_all ( ) :
return _trans . deactivate_all ( )
def _string_concat ( * strings ) :
return '  ' . join ( force_text ( s ) for s in strings )
string_concat = lazy ( _string_concat , six . text_type )
def get_language_info ( lang_code ) :
from django . conf . locale import LANG_INFO
try :
return LANG_INFO [ lang_code ]
except KeyError :
if ' _STR:0_ ' not in lang_code :
raise KeyError ( ' _STR:0_ ' % lang_code )
generic_lang_code = lang_code . split ( ' _STR:0_ ' ) [ 0 ]
try :
return LANG_INFO [ generic_lang_code ]
except KeyError :
raise KeyError ( ' _STR:0_ ' % ( lang_code , generic_lang_code ) )
trim_whitespace_re = re . compile ( ' _STR:0_ ' )
def trim_whitespace ( s ) :
return trim_whitespace_re . sub ( '   ' , s . strip ( ) )
from django . conf import settings
from django . utils . encoding import force_text
from django . utils . safestring import mark_safe , SafeData
def ngettext ( singular , plural , number ) :
if number == 1 :
return singular
return plural
ngettext_lazy = ngettext
def ungettext ( singular , plural , number ) :
return force_text ( ngettext ( singular , plural , number ) )
def pgettext ( context , message ) :
return ugettext ( message )
def npgettext ( context , singular , plural , number ) :
return ungettext ( singular , plural , number )
activate = lambda x : None
deactivate = deactivate_all = lambda : None
get_language = lambda : settings . LANGUAGE_CODE
get_language_bidi = lambda : settings . LANGUAGE_CODE in settings . LANGUAGES_BIDI
check_for_language = lambda x : True
def gettext ( message ) :
if isinstance ( message , SafeData ) :
return mark_safe ( message )
return message
def ugettext ( message ) :
return force_text ( gettext ( message ) )
gettext_noop = gettext_lazy = _ = gettext
def to_locale ( language ) :
p = language . find ( ' _STR:0_ ' )
if p >= 0 :
return language [ : p ] . lower ( ) + ' _STR:0_ ' + language [ p + 1 : ] . upper ( )
else :
return language . lower ( )
def get_language_from_request ( request , check_path = False ) :
return settings . LANGUAGE_CODE
def get_language_from_path ( request ) :
return None
from __future__ import unicode_literals
from collections import OrderedDict
import os
import re
import sys
import gettext as gettext_module
from threading import local
import warnings
from django . apps import apps
from django . conf import settings
from django . core . exceptions import AppRegistryNotReady
from django . dispatch import receiver
from django . test . signals import setting_changed
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils . encoding import force_text
from django . utils . _os import upath
from django . utils . safestring import mark_safe , SafeData
from django . utils import six , lru_cache
from django . utils . six import StringIO
from django . utils . translation import TranslatorCommentWarning , trim_whitespace , LANGUAGE_SESSION_KEY
_translations = { }
_active = local ( )
_default = None
_supported = None
CONTEXT_SEPARATOR = ' _STR:0_ '
accept_language_re = re . compile ( r '''         ([A-Za-z]{1,8}(?:-[A-Za-z0-9]{1,8})*|\*)      # "en", "en-au", "x-y-z", "es-419", "*"         (?:\s*;\s*q=(0(?:\.\d{,3})?|1(?:.0{,3})?))?   # Optional "q=1.00", "q=0.8"         (?:\s*,\s*|$)                                 # Multiple accepts per header.         '' r , re . VERBOSE )
language_code_re = re . compile ( r '_STR:0_ r , re . IGNORECASE )
language_code_prefix_re = re . compile ( r '_STR:0_ r )
_BROWSERS_DEPRECATED_LOCALES = { ' _STR:1_ ' : ' _STR:0_ ' , ' _STR:3_ ' : ' _STR:2_ ' , }
_DJANGO_DEPRECATED_LOCALES = _BROWSERS_DEPRECATED_LOCALES
@ receiver ( setting_changed )
def reset_cache ( ** kwargs ) :
if kwargs [ ' _STR:0_ ' ] in ( ' _STR:1_ ' , ' _STR:2_ ' ) :
global _supported
_supported = None
check_for_language . cache_clear ( )
get_supported_language_variant . cache_clear ( )
def to_locale ( language , to_lower = False ) :
p = language . find ( ' _STR:0_ ' )
if p >= 0 :
if to_lower :
return language [ : p ] . lower ( ) + ' _STR:0_ ' + language [ p + 1 : ] . lower ( )
else :
if len ( language [ p + 1 : ] ) > 2 :
return language [ : p ] . lower ( ) + ' _STR:0_ ' + language [ p + 1 ] . upper ( ) + language [ p + 2 : ] . lower ( )
return language [ : p ] . lower ( ) + ' _STR:0_ ' + language [ p + 1 : ] . upper ( )
else :
return language . lower ( )
def to_language ( locale ) :
p = locale . find ( ' _ ' )
if p >= 0 :
return locale [ : p ] . lower ( ) + ' - ' + locale [ p + 1 : ] . lower ( )
else :
return locale . lower ( )
class DjangoTranslation ( gettext_module . GNUTranslations ) :
def __init__ ( self , language ) :
gettext_module . GNUTranslations . __init__ ( self )
self . __language = language
self . __to_language = to_language ( language )
self . __locale = to_locale ( language )
self . plural = lambda n : int ( n != 1 )
self . _init_translation_catalog ( )
self . _add_installed_apps_translations ( )
self . _add_local_translations ( )
self . _add_fallback ( )
def __repr__ ( self ) :
return ' _STR:0_ ' % self . __language
def _new_gnu_trans ( self , localedir , use_null_fallback = True ) :
translation = gettext_module . translation ( domain = ' _STR:0_ ' , localedir = localedir , languages = [ self . __locale ] , codeset = ' utf-8 ' , fallback = use_null_fallback )
if not hasattr ( translation , ' _STR:1_ ' ) :
translation . _catalog = { }
translation . _info = { }
return translation
def _init_translation_catalog ( self ) :
settingsfile = upath ( sys . modules [ settings . __module__ ] . __file__ )
localedir = os . path . join ( os . path . dirname ( settingsfile ) , ' _STR:0_ ' )
use_null_fallback = True
if self . __language == settings . LANGUAGE_CODE :
use_null_fallback = False
translation = self . _new_gnu_trans ( localedir , use_null_fallback )
self . _info = translation . _info . copy ( )
self . _catalog = translation . _catalog . copy ( )
def _add_installed_apps_translations ( self ) :
try :
app_configs = reversed ( list ( apps . get_app_configs ( ) ) )
except AppRegistryNotReady :
raise AppRegistryNotReady ( ' _STR:0_ ' " apps registry is ready. Check that you don't make non-lazy  " " gettext calls at import time. " )
for app_config in app_configs :
localedir = os . path . join ( app_config . path , ' _STR:0_ ' )
translation = self . _new_gnu_trans ( localedir )
self . merge ( translation )
def _add_local_translations ( self ) :
for localedir in reversed ( settings . LOCALE_PATHS ) :
translation = self . _new_gnu_trans ( localedir )
self . merge ( translation )
def _add_fallback ( self ) :
if self . __language == settings . LANGUAGE_CODE or self . __language == ' _STR:0_ ' :
return
default_translation = translation ( settings . LANGUAGE_CODE )
self . add_fallback ( default_translation )
def merge ( self , other ) :
self . _catalog . update ( other . _catalog )
def language ( self ) :
return self . __language
def to_language ( self ) :
return self . __to_language
def translation ( language ) :
global _translations
if language not in _translations :
_translations [ language ] = DjangoTranslation ( language )
return _translations [ language ]
def activate ( language ) :
if language in _DJANGO_DEPRECATED_LOCALES :
msg = ( " The use of the language code '%s' is deprecated.  " " Please use the '%s' translation instead. " )
warnings . warn ( msg % ( language , _DJANGO_DEPRECATED_LOCALES [ language ] ) , RemovedInDjango19Warning , stacklevel = 2 )
_active . value = translation ( language )
def deactivate ( ) :
if hasattr ( _active , ' _STR:0_ ' ) :
del _active . value
def deactivate_all ( ) :
_active . value = gettext_module . NullTranslations ( )
def get_language ( ) :
t = getattr ( _active , " value " , None )
if t is not None :
try :
return t . to_language ( )
except AttributeError :
pass
return settings . LANGUAGE_CODE
def get_language_bidi ( ) :
base_lang = get_language ( ) . split ( ' _STR:0_ ' ) [ 0 ]
return base_lang in settings . LANGUAGES_BIDI
def catalog ( ) :
global _default
t = getattr ( _active , " value " , None )
if t is not None :
return t
if _default is None :
_default = translation ( settings . LANGUAGE_CODE )
return _default
def do_translate ( message , translation_function ) :
global _default
eol_message = message . replace ( str ( ' _STR:0_ ' ) , str ( ' _STR:1_ ' ) ) . replace ( str ( ' _STR:2_ ' ) , str ( ' _STR:1_ ' ) )
t = getattr ( _active , " value " , None )
if t is not None :
result = getattr ( t , translation_function ) ( eol_message )
else :
if _default is None :
_default = translation ( settings . LANGUAGE_CODE )
result = getattr ( _default , translation_function ) ( eol_message )
if isinstance ( message , SafeData ) :
return mark_safe ( result )
return result
def gettext ( message ) :
return do_translate ( message , ' _STR:0_ ' )
if six . PY3 :
ugettext = gettext
else :
def ugettext ( message ) :
return do_translate ( message , ' _STR:0_ ' )
def pgettext ( context , message ) :
msg_with_ctxt = " %s%s%s " % ( context , CONTEXT_SEPARATOR , message )
result = ugettext ( msg_with_ctxt )
if CONTEXT_SEPARATOR in result :
result = force_text ( message )
return result
def gettext_noop ( message ) :
return message
def do_ntranslate ( singular , plural , number , translation_function ) :
global _default
t = getattr ( _active , " value " , None )
if t is not None :
return getattr ( t , translation_function ) ( singular , plural , number )
if _default is None :
_default = translation ( settings . LANGUAGE_CODE )
return getattr ( _default , translation_function ) ( singular , plural , number )
def ngettext ( singular , plural , number ) :
return do_ntranslate ( singular , plural , number , ' _STR:0_ ' )
if six . PY3 :
ungettext = ngettext
else :
def ungettext ( singular , plural , number ) :
return do_ntranslate ( singular , plural , number , ' ungettext ' )
def npgettext ( context , singular , plural , number ) :
msgs_with_ctxt = ( " %s%s%s " % ( context , CONTEXT_SEPARATOR , singular ) , " %s%s%s " % ( context , CONTEXT_SEPARATOR , plural ) , number )
result = ungettext ( * msgs_with_ctxt )
if CONTEXT_SEPARATOR in result :
result = ungettext ( singular , plural , number )
return result
def all_locale_paths ( ) :
globalpath = os . path . join ( os . path . dirname ( upath ( sys . modules [ settings . __module__ ] . __file__ ) ) , ' locale ' )
return [ globalpath ] + list ( settings . LOCALE_PATHS )
@ lru_cache . lru_cache ( maxsize = 1000 )
def check_for_language ( lang_code ) :
if not language_code_re . search ( lang_code ) :
return False
for path in all_locale_paths ( ) :
if gettext_module . find ( ' _STR:0_ ' , path , [ to_locale ( lang_code ) ] ) is not None :
return True
return False
@ lru_cache . lru_cache ( maxsize = 1000 )
def get_supported_language_variant ( lang_code , strict = False ) :
global _supported
if _supported is None :
_supported = OrderedDict ( settings . LANGUAGES )
if lang_code :
replacement = _BROWSERS_DEPRECATED_LOCALES . get ( lang_code )
if lang_code not in _supported and replacement in _supported :
return replacement
generic_lang_code = lang_code . split ( ' _STR:0_ ' ) [ 0 ]
for code in ( lang_code , generic_lang_code ) :
if code in _supported and check_for_language ( code ) :
return code
if not strict :
for supported_code in _supported :
if supported_code . startswith ( generic_lang_code + ' _STR:0_ ' ) :
return supported_code
raise LookupError ( lang_code )
def get_language_from_path ( path , strict = False ) :
regex_match = language_code_prefix_re . match ( path )
if not regex_match :
return None
lang_code = regex_match . group ( 1 )
try :
return get_supported_language_variant ( lang_code , strict = strict )
except LookupError :
return None
def get_language_from_request ( request , check_path = False ) :
global _supported
if _supported is None :
_supported = OrderedDict ( settings . LANGUAGES )
if check_path :
lang_code = get_language_from_path ( request . path_info )
if lang_code is not None :
return lang_code
if hasattr ( request , ' _STR:0_ ' ) :
lang_code = request . session . get ( LANGUAGE_SESSION_KEY )
if lang_code in _supported and lang_code is not None and check_for_language ( lang_code ) :
return lang_code
lang_code = request . COOKIES . get ( settings . LANGUAGE_COOKIE_NAME )
try :
return get_supported_language_variant ( lang_code )
except LookupError :
pass
accept = request . META . get ( ' _STR:0_ ' , '  ' )
for accept_lang , unused in parse_accept_lang_header ( accept ) :
if accept_lang == ' _STR:0_ ' :
break
if not language_code_re . search ( accept_lang ) :
continue
try :
return get_supported_language_variant ( accept_lang )
except LookupError :
continue
try :
return get_supported_language_variant ( settings . LANGUAGE_CODE )
except LookupError :
return settings . LANGUAGE_CODE
dot_re = re . compile ( r '_STR:0_ r )
def blankout ( src , char ) :
return dot_re . sub ( char , src )
endblock_re = re . compile ( r " r ' _STR:0_ ' "  " )
plural_re = re . compile ( r " r ' _STR:0_ ' "  " )
one_percent_re = re . compile ( r " r ' _STR:0_ ' "  " )
def templatize ( src , origin = None ) :
from django . template import ( Lexer , TOKEN_TEXT , TOKEN_VAR , TOKEN_BLOCK , TOKEN_COMMENT , TRANSLATOR_COMMENT_MARK )
src = force_text ( src , settings . FILE_CHARSET )
out = StringIO ( '  ' )
message_context = None
intrans = False
inplural = False
trimmed = False
singular = [ ]
plural = [ ]
incomment = False
comment = [ ]
lineno_comment_map = { }
comment_lineno_cache = None
def join_tokens ( tokens , trim = False ) :
message = '  ' . join ( tokens )
if trim :
message = trim_whitespace ( message )
return message
for t in Lexer ( src , origin ) . tokenize ( ) :
if incomment :
if t . token_type == TOKEN_BLOCK and t . contents == ' _STR:0_ ' :
content = '  ' . join ( comment )
translators_comment_start = None
for lineno , line in enumerate ( content . splitlines ( True ) ) :
if line . lstrip ( ) . startswith ( TRANSLATOR_COMMENT_MARK ) :
translators_comment_start = lineno
for lineno , line in enumerate ( content . splitlines ( True ) ) :
if translators_comment_start is not None and lineno >= translators_comment_start :
out . write ( ' _STR:0_ ' % line )
else :
out . write ( ' _STR:0_ ' )
incomment = False
comment = [ ]
else :
comment . append ( t . contents )
elif intrans :
if t . token_type == TOKEN_BLOCK :
endbmatch = endblock_re . match ( t . contents )
pluralmatch = plural_re . match ( t . contents )
if endbmatch :
if inplural :
if message_context :
out . write ( ' _STR:1_ ' % ( message_context , join_tokens ( singular , trimmed ) , join_tokens ( plural , trimmed ) ) )
else :
out . write ( ' _STR:1_ ' % ( join_tokens ( singular , trimmed ) , join_tokens ( plural , trimmed ) ) )
for part in singular :
out . write ( blankout ( part , ' _STR:0_ ' ) )
for part in plural :
out . write ( blankout ( part , ' _STR:0_ ' ) )
else :
if message_context :
out . write ( ' _STR:1_ ' % ( message_context , join_tokens ( singular , trimmed ) ) )
else :
out . write ( ' _STR:1_ ' % join_tokens ( singular , trimmed ) )
for part in singular :
out . write ( blankout ( part , ' _STR:0_ ' ) )
message_context = None
intrans = False
inplural = False
singular = [ ]
plural = [ ]
elif pluralmatch :
inplural = True
else :
filemsg = '  '
if origin :
filemsg = ' _STR:0_ ' % origin
raise SyntaxError ( ' _STR:0_ ' % ( t . contents , filemsg , t . lineno ) )
elif t . token_type == TOKEN_VAR :
if inplural :
plural . append ( ' _STR:0_ ' % t . contents )
else :
singular . append ( ' _STR:0_ ' % t . contents )
elif t . token_type == TOKEN_TEXT :
contents = one_percent_re . sub ( ' _STR:0_ ' , t . contents )
if inplural :
plural . append ( contents )
else :
singular . append ( contents )
else :
if comment_lineno_cache is not None :
cur_lineno = t . lineno + t . contents . count ( ' _STR:0_ ' )
if comment_lineno_cache == cur_lineno :
if t . token_type != TOKEN_COMMENT :
for c in lineno_comment_map [ comment_lineno_cache ] :
filemsg = '  '
if origin :
filemsg = ' _STR:0_ ' % origin
warn_msg = ( " The translator-targeted comment '%s'  " " (%sline %d) was ignored, because it wasn't the last item  " " on the line. " ) % ( c , filemsg , comment_lineno_cache )
warnings . warn ( warn_msg , TranslatorCommentWarning )
lineno_comment_map [ comment_lineno_cache ] = [ ]
else :
out . write ( ' # %s ' % ' _STR:0_ ' . join ( lineno_comment_map [ comment_lineno_cache ] ) )
comment_lineno_cache = None
if t . token_type == TOKEN_BLOCK :
imatch = inline_re . match ( t . contents )
bmatch = block_re . match ( t . contents )
cmatches = constant_re . findall ( t . contents )
if imatch :
g = imatch . group ( 1 )
if g [ 0 ] == ' _STR:0_ ' :
g = g . strip ( ' _STR:0_ ' )
elif g [ 0 ] == ' _STR:0_ ' :
g = g . strip ( ' _STR:0_ ' )
g = one_percent_re . sub ( ' _STR:0_ ' , g )
if imatch . group ( 2 ) :
context_match = context_re . match ( imatch . group ( 2 ) )
message_context = context_match . group ( 1 )
if message_context [ 0 ] == ' _STR:0_ ' :
message_context = message_context . strip ( ' _STR:0_ ' )
elif message_context [ 0 ] == ' _STR:0_ ' :
message_context = message_context . strip ( ' _STR:0_ ' )
out . write ( ' _STR:0_ ' % ( message_context , g ) )
message_context = None
else :
out . write ( ' _STR:0_ ' % g )
elif bmatch :
for fmatch in constant_re . findall ( t . contents ) :
out . write ( ' _STR:0_ ' % fmatch )
if bmatch . group ( 1 ) :
context_match = context_re . match ( bmatch . group ( 1 ) )
message_context = context_match . group ( 1 )
if message_context [ 0 ] == ' _STR:0_ ' :
message_context = message_context . strip ( ' _STR:0_ ' )
elif message_context [ 0 ] == ' _STR:0_ ' :
message_context = message_context . strip ( ' _STR:0_ ' )
intrans = True
inplural = False
trimmed = ' _STR:0_ ' in t . split_contents ( )
singular = [ ]
plural = [ ]
elif cmatches :
for cmatch in cmatches :
out . write ( ' _STR:0_ ' % cmatch )
elif t . contents == ' _STR:0_ ' :
incomment = True
else :
out . write ( blankout ( t . contents , ' _STR:0_ ' ) )
elif t . token_type == TOKEN_VAR :
parts = t . contents . split ( ' _STR:0_ ' )
cmatch = constant_re . match ( parts [ 0 ] )
if cmatch :
out . write ( ' _STR:0_ ' % cmatch . group ( 1 ) )
for p in parts [ 1 : ] :
if p . find ( ' _STR:0_ ' ) >= 0 :
out . write ( '  %s  ' % p . split ( ' _STR:0_ ' , 1 ) [ 1 ] )
else :
out . write ( blankout ( p , ' _STR:0_ ' ) )
elif t . token_type == TOKEN_COMMENT :
if t . contents . lstrip ( ) . startswith ( TRANSLATOR_COMMENT_MARK ) :
lineno_comment_map . setdefault ( t . lineno , [ ] ) . append ( t . contents )
comment_lineno_cache = t . lineno
else :
out . write ( blankout ( t . contents , ' _STR:0_ ' ) )
return out . getvalue ( )
def parse_accept_lang_header ( lang_string ) :
result = [ ]
pieces = accept_language_re . split ( lang_string . lower ( ) )
if pieces [ - 1 ] :
return [ ]
for i in range ( 0 , len ( pieces ) - 1 , 3 ) :
first , lang , priority = pieces [ i : i + 3 ]
if first :
return [ ]
if priority :
try :
priority = float ( priority )
except ValueError :
return [ ]
if not priority :
priority = 1.0
result . append ( ( lang , priority ) )
result . sort ( key = lambda k : k [ 1 ] , reverse = True )
return result
import copy
class Node ( object ) :
default = ' _STR:0_ '
def __init__ ( self , children = None , connector = None , negated = False ) :
self . children = children [ : ] if children else [ ]
self . connector = connector or self . default
self . negated = negated
@ classmethod
def _new_instance ( cls , children = None , connector = None , negated = False ) :
obj = Node ( children , connector , negated )
obj . __class__ = cls
return obj
def __str__ ( self ) :
if self . negated :
return ' _STR:0_ ' % ( self . connector , ' _STR:1_ ' . join ( [ str ( c ) for c in self . children ] ) )
return ' _STR:0_ ' % ( self . connector , ' _STR:1_ ' . join ( [ str ( c ) for c in self . children ] ) )
def __repr__ ( self ) :
return ' _STR:0_ ' % ( self . __class__ . __name__ , self )
def __deepcopy__ ( self , memodict ) :
obj = Node ( connector = self . connector , negated = self . negated )
obj . __class__ = self . __class__
obj . children = copy . deepcopy ( self . children , memodict )
return obj
def __len__ ( self ) :
return len ( self . children )
def __bool__ ( self ) :
return bool ( self . children )
def __nonzero__ ( self ) :
return type ( self ) . __bool__ ( self )
def __contains__ ( self , other ) :
return other in self . children
def _prepare_data ( self , data ) :
return data
def add ( self , data , conn_type , squash = True ) :
if data in self . children :
return data
data = self . _prepare_data ( data )
if not squash :
self . children . append ( data )
return data
if self . connector == conn_type :
if ( isinstance ( data , Node ) and not data . negated and ( data . connector == conn_type or len ( data ) == 1 ) ) :
self . children . extend ( data . children )
return self
else :
self . children . append ( data )
return data
else :
obj = self . _new_instance ( self . children , self . connector , self . negated )
self . connector = conn_type
self . children = [ obj , data ]
return data
def negate ( self ) :
self . negated = not self . negated
from __future__ import unicode_literals
from datetime import timedelta , tzinfo
import time
import warnings
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils . encoding import force_str , force_text , DEFAULT_LOCALE_ENCODING
warnings . warn ( ' _STR:0_ ' " Use django.utils.timezone instead. " , RemovedInDjango19Warning , stacklevel = 2 )
class FixedOffset ( tzinfo ) :
def __init__ ( self , offset ) :
warnings . warn ( ' _STR:0_ ' " Use django.utils.timezone.get_fixed_timezone instead. " , RemovedInDjango19Warning )
if isinstance ( offset , timedelta ) :
self . __offset = offset
offset = self . __offset . seconds // 60
else :
self . __offset = timedelta ( minutes = offset )
sign = ' _STR:0_ ' if offset < 0 else ' _STR:1_ '
self . __name = ' _STR:0_ ' % ( sign , abs ( offset ) / 60. , abs ( offset ) % 60 )
def __repr__ ( self ) :
return self . __name
def __getinitargs__ ( self ) :
return self . __offset ,
def utcoffset ( self , dt ) :
return self . __offset
def tzname ( self , dt ) :
return self . __name
def dst ( self , dt ) :
return timedelta ( 0 )
class LocalTimezone ( tzinfo ) :
def __init__ ( self , dt ) :
warnings . warn ( ' _STR:0_ ' " Use django.utils.timezone.get_default_timezone instead. " , RemovedInDjango19Warning )
tzinfo . __init__ ( self )
self . __dt = dt
self . _tzname = self . tzname ( dt )
def __repr__ ( self ) :
return force_str ( self . _tzname )
def __getinitargs__ ( self ) :
return self . __dt ,
def utcoffset ( self , dt ) :
if self . _isdst ( dt ) :
return timedelta ( seconds = - time . altzone )
else :
return timedelta ( seconds = - time . timezone )
def dst ( self , dt ) :
if self . _isdst ( dt ) :
return timedelta ( seconds = - time . altzone ) - timedelta ( seconds = - time . timezone )
else :
return timedelta ( 0 )
def tzname ( self , dt ) :
is_dst = False if dt is None else self . _isdst ( dt )
try :
return force_text ( time . tzname [ is_dst ] , DEFAULT_LOCALE_ENCODING )
except UnicodeDecodeError :
return None
def _isdst ( self , dt ) :
tt = ( dt . year , dt . month , dt . day , dt . hour , dt . minute , dt . second , dt . weekday ( ) , 0 , 0 )
try :
stamp = time . mktime ( tt )
except ( OverflowError , ValueError ) :
tt = ( 2037 , ) + tt [ 1 : ]
stamp = time . mktime ( tt )
tt = time . localtime ( stamp )
return tt . tm_isdst > 0
from __future__ import absolute_import
import warnings
from django . utils . deprecation import RemovedInDjango19Warning
warnings . warn ( ' _STR:0_ ' , RemovedInDjango19Warning , stacklevel = 2 )
try :
from unittest2 import *
except ImportError :
from unittest import *
from __future__ import unicode_literals
import datetime
import os
import subprocess
def get_version ( version = None ) :
version = get_complete_version ( version )
major = get_major_version ( version )
sub = '  '
if version [ 3 ] == ' _STR:0_ ' and version [ 4 ] == 0 :
git_changeset = get_git_changeset ( )
if git_changeset :
sub = ' .dev%s ' % git_changeset
elif version [ 3 ] != ' _STR:0_ ' :
mapping = { ' _STR:1_ ' : ' _STR:0_ ' , ' _STR:3_ ' : ' _STR:2_ ' , ' _STR:5_ ' : ' _STR:4_ ' }
sub = mapping [ version [ 3 ] ] + str ( version [ 4 ] )
return str ( major + sub )
def get_major_version ( version = None ) :
version = get_complete_version ( version )
parts = 2 if version [ 2 ] == 0 else 3
major = ' _STR:0_ ' . join ( str ( x ) for x in version [ : parts ] )
return major
def get_complete_version ( version = None ) :
if version is None :
from django import VERSION as version
else :
assert len ( version ) == 5
assert version [ 3 ] in ( ' _STR:0_ ' , ' _STR:1_ ' , ' _STR:2_ ' , ' _STR:3_ ' )
return version
def get_git_changeset ( ) :
if hasattr ( get_git_changeset , ' _STR:0_ ' ) :
return get_git_changeset . cache
repo_dir = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) )
git_log = subprocess . Popen ( ' _STR:0_ ' , stdout = subprocess . PIPE , stderr = subprocess . PIPE , shell = True , cwd = repo_dir , universal_newlines = True )
timestamp = git_log . communicate ( ) [ 0 ]
try :
timestamp = datetime . datetime . utcfromtimestamp ( int ( timestamp ) )
except ValueError :
changeset = None
else :
changeset = timestamp . strftime ( ' _STR:0_ ' )
get_git_changeset . cache = changeset
return changeset
from xml . sax . saxutils import XMLGenerator
class SimplerXMLGenerator ( XMLGenerator ) :
def addQuickElement ( self , name , contents = None , attrs = None ) :
if attrs is None :
attrs = { }
self . startElement ( name , attrs )
if contents is not None :
self . characters ( contents )
self . endElement ( name )
